{
  "address": "0xb90e1aa0808537b1b9755ec347a54a0ada55f63f",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract VaultConfigurationModule",
          "name": "_configModule",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "contract Authority",
          "name": "_authority",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Authority",
          "name": "authority",
          "type": "address"
        }
      ],
      "name": "AuthorityUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract VaultConfigurationModule",
          "name": "newConfigModule",
          "type": "address"
        }
      ],
      "name": "ConfigModuleUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnerUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "authority",
      "outputs": [
        {
          "internalType": "contract Authority",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "configModule",
      "outputs": [
        {
          "internalType": "contract VaultConfigurationModule",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "initializeVault",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Authority",
          "name": "newAuthority",
          "type": "address"
        }
      ],
      "name": "setAuthority",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract VaultConfigurationModule",
          "name": "newConfigModule",
          "type": "address"
        }
      ],
      "name": "setConfigModule",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "setOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf1428f098c4716e11acbb31a862f1ef18edb1369d82fab80c45dfe67214a68b4",
  "receipt": {
    "to": null,
    "from": "0xf09c27934a92c56c7c0dd6cbac858c35fbd5170f",
    "contractAddress": "0xb90e1aa0808537b1b9755ec347a54a0ada55f63f",
    "transactionIndex": "0x7",
    "gasUsed": "0x70908",
    "logsBloom": "0x00000000000000000000000020000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000800000000000000000000000000000000000000000000000000008000000000000000000000000000080000000000000000000000000000000000000001000000000000000000002000000000000000000000008100000200000000000000000000000000000000200000000800000000000000008000000000000000000000000000000000000000000",
    "blockHash": "0x1baa482dc5db631e565823722b90bc1aab2a10b6fe7db2a356cffeee9e95338f",
    "transactionHash": "0xf1428f098c4716e11acbb31a862f1ef18edb1369d82fab80c45dfe67214a68b4",
    "logs": [
      {
        "address": "0xb90e1aa0808537b1b9755ec347a54a0ada55f63f",
        "topics": [
          "0x4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b",
          "0x000000000000000000000000f09c27934a92c56c7c0dd6cbac858c35fbd5170f"
        ],
        "data": "0x",
        "blockNumber": "0x7fba58",
        "transactionHash": "0xf1428f098c4716e11acbb31a862f1ef18edb1369d82fab80c45dfe67214a68b4",
        "transactionIndex": "0x7",
        "blockHash": "0x1baa482dc5db631e565823722b90bc1aab2a10b6fe7db2a356cffeee9e95338f",
        "logIndex": "0x2b",
        "removed": false
      },
      {
        "address": "0xb90e1aa0808537b1b9755ec347a54a0ada55f63f",
        "topics": [
          "0x2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad",
          "0x000000000000000000000000e669f5f83616639d3442b03108233e0054afbef8"
        ],
        "data": "0x",
        "blockNumber": "0x7fba58",
        "transactionHash": "0xf1428f098c4716e11acbb31a862f1ef18edb1369d82fab80c45dfe67214a68b4",
        "transactionIndex": "0x7",
        "blockHash": "0x1baa482dc5db631e565823722b90bc1aab2a10b6fe7db2a356cffeee9e95338f",
        "logIndex": "0x2c",
        "removed": false
      }
    ],
    "blockNumber": "0x7fba58",
    "cumulativeGasUsed": "0x15fc47",
    "status": "0x1"
  },
  "args": [
    "0x5672E5aCbBbb467Feaf91327C847824Dd1C4f4B9",
    "0xf09c27934A92c56c7C0dD6cBAc858C35fBd5170f",
    "0xE669f5f83616639D3442b03108233E0054afbef8"
  ],
  "solcInputHash": "9dd7be47a0ead41cf23f6aa7653a5c36",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract VaultConfigurationModule\",\"name\":\"_configModule\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract VaultConfigurationModule\",\"name\":\"newConfigModule\",\"type\":\"address\"}],\"name\":\"ConfigModuleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"configModule\",\"outputs\":[{\"internalType\":\"contract VaultConfigurationModule\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"initializeVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract VaultConfigurationModule\",\"name\":\"newConfigModule\",\"type\":\"address\"}],\"name\":\"setConfigModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Transmissions11 and JetJadeja\",\"events\":{\"ConfigModuleUpdated(address)\":{\"params\":{\"newConfigModule\":\"The new configuration module.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_authority\":\"The Authority of the module.\",\"_configModule\":\"The Vault configuration module the module will use to configure Vaults before initialization.\",\"_owner\":\"The owner of the module.\"}},\"initializeVault(address)\":{\"details\":\"This will revert if the Vault has already been initialized.\",\"params\":{\"vault\":\"The Vault to configure and initialize.\"}},\"setConfigModule(address)\":{\"params\":{\"newConfigModule\":\"The Vault configuration module to set.\"}}},\"title\":\"Rari Vault Initialization Module\",\"version\":1},\"userdoc\":{\"events\":{\"ConfigModuleUpdated(address)\":{\"notice\":\"Emitted when the config module is updated.\"}},\"kind\":\"user\",\"methods\":{\"configModule()\":{\"notice\":\"Vault configuration module used to configure Vaults before initialization.\"},\"constructor\":{\"notice\":\"Creates a Vault initialization module.\"},\"initializeVault(address)\":{\"notice\":\"Properly configures and initializes a newly deployed Vault.\"},\"setConfigModule(address)\":{\"notice\":\"Sets a new Vault configuration module.\"}},\"notice\":\"Module for initializing newly created Vaults.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/vault/modules/VaultInitializationModule.sol\":\"VaultInitializationModule\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"},\"solmate/src/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.0;\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed owner);\\n\\n    event AuthorityUpdated(Authority indexed authority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(_owner);\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(owner);\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual requiresAuth {\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(authority);\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority cachedAuthority = authority;\\n\\n        if (address(cachedAuthority) != address(0)) {\\n            try cachedAuthority.canCall(user, address(this), functionSig) returns (bool canCall) {\\n                if (canCall) return true;\\n            } catch {}\\n        }\\n\\n        return user == owner;\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x0b7f3c8e86c2b09d3498733bda5247da69956c971224f4e2a2a4e15d75eed707\",\"license\":\"AGPL-3.0\"},\"solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] -= amount;\\n        }\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_PERMIT_SIGNATURE\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(bytes(\\\"1\\\")),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x058e0708ffdd2b04a17b96b5775d9fab8daa19d3cd37d26ce6c923679bf9cc9a\",\"license\":\"AGPL-3.0\"},\"solmate/src/tokens/WETH.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) external {\\n        _burn(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n    }\\n\\n    receive() external payable {\\n        deposit();\\n    }\\n}\\n\",\"keccak256\":\"0x2d4eb620bad85b3bf6d5e8e4f4c53eb672c62ca4c9e053d3879d26a9d9996989\",\"license\":\"AGPL-3.0\"},\"solmate/src/utils/Bytes32AddressLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.0;\\n\\n/// @notice Library for converting between addresses and bytes32 values.\\n/// @author Original work by Transmissions11 (https://github.com/transmissions11)\\nlibrary Bytes32AddressLib {\\n    function fromLast20Bytes(bytes32 bytesValue) internal pure returns (address) {\\n        return address(uint160(uint256(bytesValue)));\\n    }\\n\\n    function fillLast12Bytes(address addressValue) internal pure returns (bytes32) {\\n        return bytes32(bytes20(addressValue));\\n    }\\n}\\n\",\"keccak256\":\"0x5eb32bbee24cd9ac132b005d0c5f3c2ef982ff4458f2bfaabc79e1207cf1c1e4\",\"license\":\"AGPL-3.0\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Modified from Dappsys V2 (https://github.com/dapp-org/dappsys-v2/blob/main/src/math.sol)\\n/// and ABDK (https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol)\\nlibrary FixedPointMathLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            COMMON BASE UNITS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant YAD = 1e8;\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant RAD = 1e45;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n            // If baseUnit is zero this will return zero instead of reverting.\\n            z := div(z, baseUnit)\\n        }\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * baseUnit in z for now.\\n            z := mul(x, baseUnit)\\n\\n            if or(\\n                // Revert if y is zero to ensure we don't divide by zero below.\\n                iszero(y),\\n                // Equivalent to require(x == 0 || (x * baseUnit) / x == baseUnit)\\n                iszero(or(iszero(x), eq(div(z, x), baseUnit)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            // We ensure y is not zero above, so there is never division by zero here.\\n            z := div(z, y)\\n        }\\n    }\\n\\n    function fpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    z := baseUnit\\n                }\\n                default {\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    z := baseUnit\\n                }\\n                default {\\n                    z := x\\n                }\\n                let half := div(baseUnit, 2)\\n                for {\\n                    n := div(n, 2)\\n                } n {\\n                    n := div(n, 2)\\n                } {\\n                    let xx := mul(x, x)\\n                    if iszero(eq(div(xx, x), x)) {\\n                        revert(0, 0)\\n                    }\\n                    let xxRound := add(xx, half)\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n                    x := div(xxRound, baseUnit)\\n                    if mod(n, 2) {\\n                        let zx := mul(z, x)\\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\\n                            revert(0, 0)\\n                        }\\n                        let zxRound := add(zx, half)\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n                        z := div(zxRound, baseUnit)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) return 0;\\n\\n        result = 1;\\n\\n        uint256 xAux = x;\\n\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n\\n        if (xAux >= 0x8) result <<= 1;\\n\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n\\n            uint256 roundedDownResult = x / result;\\n\\n            if (result > roundedDownResult) result = roundedDownResult;\\n        }\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x > y ? x : y;\\n    }\\n}\\n\",\"keccak256\":\"0x11bae04ee197bfb3b5dbb4a95eae81f500314b76be91ad692b10f00782fc9bf6\",\"license\":\"AGPL-3.0\"},\"solmate/src/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x <= type(uint248).max);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x <= type(uint128).max);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x <= type(uint96).max);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x <= type(uint64).max);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x <= type(uint32).max);\\n\\n        y = uint32(x);\\n    }\\n}\\n\",\"keccak256\":\"0x58d6e9ae42c781636b8a953a009d95da627b8d1def3905245d1ccc7ffd954a1e\",\"license\":\"AGPL-3.0\"},\"solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x50f187c86835070ec519acffcc259cd7900fdb85cb53333210fba9491eb65eca\",\"license\":\"AGPL-3.0\"},\"src/vault/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\nimport { Auth } from \\\"solmate/src/auth/Auth.sol\\\";\\nimport { WETH } from \\\"solmate/src/tokens/WETH.sol\\\";\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\nimport { SafeCastLib } from \\\"solmate/src/utils/SafeCastLib.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\nimport { Strategy, ERC20Strategy, ETHStrategy } from \\\"./interfaces/Strategy.sol\\\";\\n\\n/// @title Rari Vault (rvToken)\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Flexible, minimalist, and gas-optimized yield\\n/// aggregator for earning interest on any ERC20 token.\\ncontract Vault is ERC20, Auth {\\n\\tusing SafeCastLib for uint256;\\n\\tusing SafeTransferLib for ERC20;\\n\\tusing FixedPointMathLib for uint256;\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                                IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice The underlying token the Vault accepts.\\n\\tERC20 public immutable UNDERLYING;\\n\\n\\t/// @notice The base unit of the underlying token and hence rvToken.\\n\\t/// @dev Equal to 10 ** decimals. Used for fixed point arithmetic.\\n\\tuint256 public immutable BASE_UNIT;\\n\\n\\t/// @notice Creates a new Vault that accepts a specific underlying token.\\n\\t/// @param _UNDERLYING The ERC20 compliant token the Vault should accept.\\n\\tconstructor(ERC20 _UNDERLYING)\\n\\t\\tERC20(\\n\\t\\t\\t// ex: Parasite Dai Stablecoin Vault\\n\\t\\t\\tstring(abi.encodePacked(\\\"Parasite \\\", _UNDERLYING.name(), \\\" Vault\\\")),\\n\\t\\t\\t// ex: pDAI\\n\\t\\t\\tstring(abi.encodePacked(\\\"p\\\", _UNDERLYING.symbol())),\\n\\t\\t\\t// ex: 18\\n\\t\\t\\t_UNDERLYING.decimals()\\n\\t\\t)\\n\\t\\tAuth(Auth(msg.sender).owner(), Auth(msg.sender).authority())\\n\\t{\\n\\t\\tUNDERLYING = _UNDERLYING;\\n\\n\\t\\tBASE_UNIT = 10**decimals;\\n\\n\\t\\t// Prevent minting of rvTokens until\\n\\t\\t// the initialize function is called.\\n\\t\\ttotalSupply = type(uint256).max;\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                           FEE CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice The percentage of profit recognized each harvest to reserve as fees.\\n\\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n\\tuint256 public feePercent;\\n\\n\\t/// @notice Emitted when the fee percentage is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newFeePercent The new fee percentage.\\n\\tevent FeePercentUpdated(address indexed user, uint256 newFeePercent);\\n\\n\\t/// @notice Sets a new fee percentage.\\n\\t/// @param newFeePercent The new fee percentage.\\n\\tfunction setFeePercent(uint256 newFeePercent) external requiresAuth {\\n\\t\\t// A fee percentage over 100% doesn't make sense.\\n\\t\\trequire(newFeePercent <= 1e18, \\\"FEE_TOO_HIGH\\\");\\n\\n\\t\\t// Update the fee percentage.\\n\\t\\tfeePercent = newFeePercent;\\n\\n\\t\\temit FeePercentUpdated(msg.sender, newFeePercent);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                        HARVEST CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when the harvest window is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newHarvestWindow The new harvest window.\\n\\tevent HarvestWindowUpdated(address indexed user, uint128 newHarvestWindow);\\n\\n\\t/// @notice Emitted when the harvest delay is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newHarvestDelay The new harvest delay.\\n\\tevent HarvestDelayUpdated(address indexed user, uint64 newHarvestDelay);\\n\\n\\t/// @notice Emitted when the harvest delay is scheduled to be updated next harvest.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newHarvestDelay The scheduled updated harvest delay.\\n\\tevent HarvestDelayUpdateScheduled(address indexed user, uint64 newHarvestDelay);\\n\\n\\t/// @notice The period in seconds during which multiple harvests can occur\\n\\t/// regardless if they are taking place before the harvest delay has elapsed.\\n\\t/// @dev Long harvest windows open the Vault up to profit distribution slowdown attacks.\\n\\tuint128 public harvestWindow;\\n\\n\\t/// @notice The period in seconds over which locked profit is unlocked.\\n\\t/// @dev Cannot be 0 as it opens harvests up to sandwich attacks.\\n\\tuint64 public harvestDelay;\\n\\n\\t/// @notice The value that will replace harvestDelay next harvest.\\n\\t/// @dev In the case that the next delay is 0, no update will be applied.\\n\\tuint64 public nextHarvestDelay;\\n\\n\\t/// @notice Sets a new harvest window.\\n\\t/// @param newHarvestWindow The new harvest window.\\n\\t/// @dev The Vault's harvestDelay must already be set before calling.\\n\\tfunction setHarvestWindow(uint128 newHarvestWindow) external requiresAuth {\\n\\t\\t// A harvest window longer than the harvest delay doesn't make sense.\\n\\t\\trequire(newHarvestWindow <= harvestDelay, \\\"WINDOW_TOO_LONG\\\");\\n\\n\\t\\t// Update the harvest window.\\n\\t\\tharvestWindow = newHarvestWindow;\\n\\n\\t\\temit HarvestWindowUpdated(msg.sender, newHarvestWindow);\\n\\t}\\n\\n\\t/// @notice Sets a new harvest delay.\\n\\t/// @param newHarvestDelay The new harvest delay to set.\\n\\t/// @dev If the current harvest delay is 0, meaning it has not\\n\\t/// been set before, it will be updated immediately, otherwise\\n\\t/// it will be scheduled to take effect after the next harvest.\\n\\tfunction setHarvestDelay(uint64 newHarvestDelay) external requiresAuth {\\n\\t\\t// A harvest delay of 0 makes harvests vulnerable to sandwich attacks.\\n\\t\\trequire(newHarvestDelay != 0, \\\"DELAY_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// A harvest delay longer than 1 year doesn't make sense.\\n\\t\\trequire(newHarvestDelay <= 365 days, \\\"DELAY_TOO_LONG\\\");\\n\\n\\t\\t// If the harvest delay is 0, meaning it has not been set before:\\n\\t\\tif (harvestDelay == 0) {\\n\\t\\t\\t// We'll apply the update immediately.\\n\\t\\t\\tharvestDelay = newHarvestDelay;\\n\\n\\t\\t\\temit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n\\t\\t} else {\\n\\t\\t\\t// We'll apply the update next harvest.\\n\\t\\t\\tnextHarvestDelay = newHarvestDelay;\\n\\n\\t\\t\\temit HarvestDelayUpdateScheduled(msg.sender, newHarvestDelay);\\n\\t\\t}\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                       TARGET FLOAT CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice The desired percentage of the Vault's holdings to keep as float.\\n\\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n\\tuint256 public targetFloatPercent;\\n\\n\\t/// @notice Emitted when the target float percentage is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newTargetFloatPercent The new target float percentage.\\n\\tevent TargetFloatPercentUpdated(address indexed user, uint256 newTargetFloatPercent);\\n\\n\\t/// @notice Set a new target float percentage.\\n\\t/// @param newTargetFloatPercent The new target float percentage.\\n\\tfunction setTargetFloatPercent(uint256 newTargetFloatPercent) external requiresAuth {\\n\\t\\t// A target float percentage over 100% doesn't make sense.\\n\\t\\trequire(targetFloatPercent <= 1e18, \\\"TARGET_TOO_HIGH\\\");\\n\\n\\t\\t// Update the target float percentage.\\n\\t\\ttargetFloatPercent = newTargetFloatPercent;\\n\\n\\t\\temit TargetFloatPercentUpdated(msg.sender, newTargetFloatPercent);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                   UNDERLYING IS WETH CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Whether the Vault should treat the underlying token as WETH compatible.\\n\\t/// @dev If enabled the Vault will allow trusting strategies that accept Ether.\\n\\tbool public underlyingIsWETH;\\n\\n\\t/// @notice Emitted when whether the Vault should treat the underlying as WETH is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newUnderlyingIsWETH Whether the Vault nows treats the underlying as WETH.\\n\\tevent UnderlyingIsWETHUpdated(address indexed user, bool newUnderlyingIsWETH);\\n\\n\\t/// @notice Sets whether the Vault treats the underlying as WETH.\\n\\t/// @param newUnderlyingIsWETH Whether the Vault should treat the underlying as WETH.\\n\\t/// @dev The underlying token must have 18 decimals, to match Ether's decimal scheme.\\n\\tfunction setUnderlyingIsWETH(bool newUnderlyingIsWETH) external requiresAuth {\\n\\t\\t// Ensure the underlying token's decimals match ETH.\\n\\t\\trequire(UNDERLYING.decimals() == 18, \\\"WRONG_DECIMALS\\\");\\n\\n\\t\\t// Update whether the Vault treats the underlying as WETH.\\n\\t\\tunderlyingIsWETH = newUnderlyingIsWETH;\\n\\n\\t\\temit UnderlyingIsWETHUpdated(msg.sender, newUnderlyingIsWETH);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                          STRATEGY STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice The total amount of underlying tokens held in strategies at the time of the last harvest.\\n\\t/// @dev Includes maxLockedProfit, must be correctly subtracted to compute available/free holdings.\\n\\tuint256 public totalStrategyHoldings;\\n\\n\\t/// @dev Packed struct of strategy data.\\n\\t/// @param trusted Whether the strategy is trusted.\\n\\t/// @param balance The amount of underlying tokens held in the strategy.\\n\\tstruct StrategyData {\\n\\t\\t// Used to determine if the Vault will operate on a strategy.\\n\\t\\tbool trusted;\\n\\t\\t// Used to determine profit and loss during harvests of the strategy.\\n\\t\\tuint248 balance;\\n\\t}\\n\\n\\t/// @notice Maps strategies to data the Vault holds on them.\\n\\tmapping(Strategy => StrategyData) public getStrategyData;\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                             HARVEST STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice A timestamp representing when the first harvest in the most recent harvest window occurred.\\n\\t/// @dev May be equal to lastHarvest if there was/has only been one harvest in the most last/current window.\\n\\tuint64 public lastHarvestWindowStart;\\n\\n\\t/// @notice A timestamp representing when the most recent harvest occurred.\\n\\tuint64 public lastHarvest;\\n\\n\\t/// @notice The amount of locked profit at the end of the last harvest.\\n\\tuint128 public maxLockedProfit;\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                        WITHDRAWAL QUEUE STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice An ordered array of strategies representing the withdrawal queue.\\n\\t/// @dev The queue is processed in descending order, meaning the last index will be withdrawn from first.\\n\\t/// @dev Strategies that are untrusted, duplicated, or have no balance are filtered out when encountered at\\n\\t/// withdrawal time, not validated upfront, meaning the queue may not reflect the \\\"true\\\" set used for withdrawals.\\n\\tStrategy[] public withdrawalQueue;\\n\\n\\t/// @notice Gets the full withdrawal queue.\\n\\t/// @return An ordered array of strategies representing the withdrawal queue.\\n\\t/// @dev This is provided because Solidity converts public arrays into index getters,\\n\\t/// but we need a way to allow external contracts and users to access the whole array.\\n\\tfunction getWithdrawalQueue() external view returns (Strategy[] memory) {\\n\\t\\treturn withdrawalQueue;\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after a successful deposit.\\n\\t/// @param user The address that deposited into the Vault.\\n\\t/// @param underlyingAmount The amount of underlying tokens that were deposited.\\n\\tevent Deposit(address indexed user, uint256 underlyingAmount);\\n\\n\\t/// @notice Emitted after a successful withdrawal.\\n\\t/// @param user The address that withdrew from the Vault.\\n\\t/// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n\\tevent Withdraw(address indexed user, uint256 underlyingAmount);\\n\\n\\t/// @notice Deposit a specific amount of underlying tokens.\\n\\t/// @param underlyingAmount The amount of the underlying token to deposit.\\n\\tfunction deposit(uint256 underlyingAmount) external {\\n\\t\\t// We don't allow depositing 0 to prevent emitting a useless event.\\n\\t\\trequire(underlyingAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Determine the equivalent amount of rvTokens and mint them.\\n\\t\\t_mint(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n\\t\\temit Deposit(msg.sender, underlyingAmount);\\n\\n\\t\\t// Transfer in underlying tokens from the user.\\n\\t\\t// This will revert if the user does not have the amount specified.\\n\\t\\tUNDERLYING.safeTransferFrom(msg.sender, address(this), underlyingAmount);\\n\\t}\\n\\n\\t/// @notice Withdraw a specific amount of underlying tokens.\\n\\t/// @param underlyingAmount The amount of underlying tokens to withdraw.\\n\\tfunction withdraw(uint256 underlyingAmount) external {\\n\\t\\t// We don't allow withdrawing 0 to prevent emitting a useless event.\\n\\t\\trequire(underlyingAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Determine the equivalent amount of rvTokens and burn them.\\n\\t\\t// This will revert if the user does not have enough rvTokens.\\n\\t\\t_burn(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n\\t\\temit Withdraw(msg.sender, underlyingAmount);\\n\\n\\t\\t// Withdraw from strategies if needed and transfer.\\n\\t\\ttransferUnderlyingTo(msg.sender, underlyingAmount);\\n\\t}\\n\\n\\t/// @notice Redeem a specific amount of rvTokens for underlying tokens.\\n\\t/// @param rvTokenAmount The amount of rvTokens to redeem for underlying tokens.\\n\\tfunction redeem(uint256 rvTokenAmount) external {\\n\\t\\t// We don't allow redeeming 0 to prevent emitting a useless event.\\n\\t\\trequire(rvTokenAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Determine the equivalent amount of underlying tokens.\\n\\t\\tuint256 underlyingAmount = rvTokenAmount.fmul(exchangeRate(), BASE_UNIT);\\n\\n\\t\\t// Burn the provided amount of rvTokens.\\n\\t\\t// This will revert if the user does not have enough rvTokens.\\n\\t\\t_burn(msg.sender, rvTokenAmount);\\n\\n\\t\\temit Withdraw(msg.sender, underlyingAmount);\\n\\t\\t// Withdraw from strategies if needed and transfer.\\n\\t\\ttransferUnderlyingTo(msg.sender, underlyingAmount);\\n\\t}\\n\\n\\t/// @dev Transfers a specific amount of underlying tokens held in strategies and/or float to a recipient.\\n\\t/// @dev Only withdraws from strategies if needed and maintains the target float percentage if possible.\\n\\t/// @param recipient The user to transfer the underlying tokens to.\\n\\t/// @param underlyingAmount The amount of underlying tokens to transfer.\\n\\tfunction transferUnderlyingTo(address recipient, uint256 underlyingAmount) internal {\\n\\t\\t// Get the Vault's floating balance.\\n\\t\\tuint256 float = totalFloat();\\n\\n\\t\\t// If the amount is greater than the float, withdraw from strategies.\\n\\t\\tif (underlyingAmount > float) {\\n\\t\\t\\t// Compute the amount needed to reach our target float percentage.\\n\\t\\t\\tuint256 floatMissingForTarget = (totalHoldings() - underlyingAmount).fmul(\\n\\t\\t\\t\\ttargetFloatPercent,\\n\\t\\t\\t\\t1e18\\n\\t\\t\\t);\\n\\n\\t\\t\\t// Compute the bare minimum amount we need for this withdrawal.\\n\\t\\t\\tuint256 floatMissingForWithdrawal = underlyingAmount - float;\\n\\n\\t\\t\\t// Pull enough to cover the withdrawal and reach our target float percentage.\\n\\t\\t\\tpullFromWithdrawalQueue(floatMissingForWithdrawal + floatMissingForTarget);\\n\\t\\t}\\n\\n\\t\\t// Transfer the provided amount of underlying tokens.\\n\\t\\tUNDERLYING.safeTransfer(recipient, underlyingAmount);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                        VAULT ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Returns a user's Vault balance in underlying tokens.\\n\\t/// @param user The user to get the underlying balance of.\\n\\t/// @return The user's Vault balance in underlying tokens.\\n\\tfunction balanceOfUnderlying(address user) external view returns (uint256) {\\n\\t\\treturn balanceOf[user].fmul(exchangeRate(), BASE_UNIT);\\n\\t}\\n\\n\\t/// @notice Returns the amount of underlying tokens an rvToken can be redeemed for.\\n\\t/// @return The amount of underlying tokens an rvToken can be redeemed for.\\n\\tfunction exchangeRate() public view returns (uint256) {\\n\\t\\t// Get the total supply of rvTokens.\\n\\t\\tuint256 rvTokenSupply = totalSupply;\\n\\n\\t\\t// If there are no rvTokens in circulation, return an exchange rate of 1:1.\\n\\t\\tif (rvTokenSupply == 0) return BASE_UNIT;\\n\\n\\t\\t// Calculate the exchange rate by dividing the total holdings by the rvToken supply.\\n\\t\\treturn totalHoldings().fdiv(rvTokenSupply, BASE_UNIT);\\n\\t}\\n\\n\\t/// @notice Calculates the total amount of underlying tokens the Vault holds.\\n\\t/// @return totalUnderlyingHeld The total amount of underlying tokens the Vault holds.\\n\\tfunction totalHoldings() public view returns (uint256 totalUnderlyingHeld) {\\n\\t\\tunchecked {\\n\\t\\t\\t// Cannot underflow as locked profit can't exceed total strategy holdings.\\n\\t\\t\\ttotalUnderlyingHeld = totalStrategyHoldings - lockedProfit();\\n\\t\\t}\\n\\n\\t\\t// Include our floating balance in the total.\\n\\t\\ttotalUnderlyingHeld += totalFloat();\\n\\t}\\n\\n\\t/// @notice Calculates the current amount of locked profit.\\n\\t/// @return The current amount of locked profit.\\n\\tfunction lockedProfit() public view returns (uint256) {\\n\\t\\t// Get the last harvest and harvest delay.\\n\\t\\tuint256 previousHarvest = lastHarvest;\\n\\t\\tuint256 harvestInterval = harvestDelay;\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// If the harvest delay has passed, there is no locked profit.\\n\\t\\t\\t// Cannot overflow on human timescales since harvestInterval is capped.\\n\\t\\t\\tif (block.timestamp >= previousHarvest + harvestInterval) return 0;\\n\\n\\t\\t\\t// Get the maximum amount we could return.\\n\\t\\t\\tuint256 maximumLockedProfit = maxLockedProfit;\\n\\n\\t\\t\\t// Compute how much profit remains locked based on the last harvest and harvest delay.\\n\\t\\t\\t// It's impossible for the previous harvest to be in the future, so this will never underflow.\\n\\t\\t\\treturn\\n\\t\\t\\t\\tmaximumLockedProfit -\\n\\t\\t\\t\\t(maximumLockedProfit * (block.timestamp - previousHarvest)) /\\n\\t\\t\\t\\tharvestInterval;\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Returns the amount of underlying tokens that idly sit in the Vault.\\n\\t/// @return The amount of underlying tokens that sit idly in the Vault.\\n\\tfunction totalFloat() public view returns (uint256) {\\n\\t\\treturn UNDERLYING.balanceOf(address(this));\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                             HARVEST LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after a successful harvest.\\n\\t/// @param user The authorized user who triggered the harvest.\\n\\t/// @param strategies The trusted strategies that were harvested.\\n\\tevent Harvest(address indexed user, Strategy[] strategies);\\n\\n\\t/// @notice Harvest a set of trusted strategies.\\n\\t/// @param strategies The trusted strategies to harvest.\\n\\t/// @dev Will always revert if called outside of an active\\n\\t/// harvest window or before the harvest delay has passed.\\n\\tfunction harvest(Strategy[] calldata strategies) external requiresAuth {\\n\\t\\t// If this is the first harvest after the last window:\\n\\t\\tif (block.timestamp >= lastHarvest + harvestDelay) {\\n\\t\\t\\t// Set the harvest window's start timestamp.\\n\\t\\t\\t// Cannot overflow 64 bits on human timescales.\\n\\t\\t\\tlastHarvestWindowStart = uint64(block.timestamp);\\n\\t\\t} else {\\n\\t\\t\\t// We know this harvest is not the first in the window so we need to ensure it's within it.\\n\\t\\t\\trequire(block.timestamp <= lastHarvestWindowStart + harvestWindow, \\\"BAD_HARVEST_TIME\\\");\\n\\t\\t}\\n\\n\\t\\t// Get the Vault's current total strategy holdings.\\n\\t\\tuint256 oldTotalStrategyHoldings = totalStrategyHoldings;\\n\\n\\t\\t// Used to store the total profit accrued by the strategies.\\n\\t\\tuint256 totalProfitAccrued;\\n\\n\\t\\t// Used to store the new total strategy holdings after harvesting.\\n\\t\\tuint256 newTotalStrategyHoldings = oldTotalStrategyHoldings;\\n\\n\\t\\t// Will revert if any of the specified strategies are untrusted.\\n\\t\\tfor (uint256 i = 0; i < strategies.length; i++) {\\n\\t\\t\\t// Get the strategy at the current index.\\n\\t\\t\\tStrategy strategy = strategies[i];\\n\\n\\t\\t\\t// If an untrusted strategy could be harvested a malicious user could use\\n\\t\\t\\t// a fake strategy that over-reports holdings to manipulate the exchange rate.\\n\\t\\t\\trequire(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n\\t\\t\\t// Get the strategy's previous and current balance.\\n\\t\\t\\tuint256 balanceLastHarvest = getStrategyData[strategy].balance;\\n\\t\\t\\tuint256 balanceThisHarvest = strategy.balanceOfUnderlying(address(this));\\n\\n\\t\\t\\t// Update the strategy's stored balance. Cast overflow is unrealistic.\\n\\t\\t\\tgetStrategyData[strategy].balance = balanceThisHarvest.safeCastTo248();\\n\\n\\t\\t\\t// Increase/decrease newTotalStrategyHoldings based on the profit/loss registered.\\n\\t\\t\\t// We cannot wrap the subtraction in parenthesis as it would underflow if the strategy had a loss.\\n\\t\\t\\tnewTotalStrategyHoldings =\\n\\t\\t\\t\\tnewTotalStrategyHoldings +\\n\\t\\t\\t\\tbalanceThisHarvest -\\n\\t\\t\\t\\tbalanceLastHarvest;\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t// Update the total profit accrued while counting losses as zero profit.\\n\\t\\t\\t\\t// Cannot overflow as we already increased total holdings without reverting.\\n\\t\\t\\t\\ttotalProfitAccrued += balanceThisHarvest > balanceLastHarvest\\n\\t\\t\\t\\t\\t? balanceThisHarvest - balanceLastHarvest // Profits since last harvest.\\n\\t\\t\\t\\t\\t: 0; // If the strategy registered a net loss we don't have any new profit.\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Compute fees as the fee percent multiplied by the profit.\\n\\t\\tuint256 feesAccrued = totalProfitAccrued.fmul(feePercent, 1e18);\\n\\n\\t\\t// If we accrued any fees, mint an equivalent amount of rvTokens.\\n\\t\\t// Authorized users can claim the newly minted rvTokens via claimFees.\\n\\t\\t_mint(address(this), feesAccrued.fdiv(exchangeRate(), BASE_UNIT));\\n\\n\\t\\t// Update max unlocked profit based on any remaining locked profit plus new profit.\\n\\t\\tmaxLockedProfit = (lockedProfit() + totalProfitAccrued - feesAccrued).safeCastTo128();\\n\\n\\t\\t// Set strategy holdings to our new total.\\n\\t\\ttotalStrategyHoldings = newTotalStrategyHoldings;\\n\\n\\t\\t// Update the last harvest timestamp.\\n\\t\\t// Cannot overflow on human timescales.\\n\\t\\tlastHarvest = uint64(block.timestamp);\\n\\n\\t\\temit Harvest(msg.sender, strategies);\\n\\n\\t\\t// Get the next harvest delay.\\n\\t\\tuint64 newHarvestDelay = nextHarvestDelay;\\n\\n\\t\\t// If the next harvest delay is not 0:\\n\\t\\tif (newHarvestDelay != 0) {\\n\\t\\t\\t// Update the harvest delay.\\n\\t\\t\\tharvestDelay = newHarvestDelay;\\n\\n\\t\\t\\t// Reset the next harvest delay.\\n\\t\\t\\tnextHarvestDelay = 0;\\n\\n\\t\\t\\temit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n\\t\\t}\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                    STRATEGY DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after the Vault deposits into a strategy contract.\\n\\t/// @param user The authorized user who triggered the deposit.\\n\\t/// @param strategy The strategy that was deposited into.\\n\\t/// @param underlyingAmount The amount of underlying tokens that were deposited.\\n\\tevent StrategyDeposit(\\n\\t\\taddress indexed user,\\n\\t\\tStrategy indexed strategy,\\n\\t\\tuint256 underlyingAmount\\n\\t);\\n\\n\\t/// @notice Emitted after the Vault withdraws funds from a strategy contract.\\n\\t/// @param user The authorized user who triggered the withdrawal.\\n\\t/// @param strategy The strategy that was withdrawn from.\\n\\t/// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n\\tevent StrategyWithdrawal(\\n\\t\\taddress indexed user,\\n\\t\\tStrategy indexed strategy,\\n\\t\\tuint256 underlyingAmount\\n\\t);\\n\\n\\t/// @notice Deposit a specific amount of float into a trusted strategy.\\n\\t/// @param strategy The trusted strategy to deposit into.\\n\\t/// @param underlyingAmount The amount of underlying tokens in float to deposit.\\n\\tfunction depositIntoStrategy(Strategy strategy, uint256 underlyingAmount)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// A strategy must be trusted before it can be deposited into.\\n\\t\\trequire(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n\\t\\t// We don't allow depositing 0 to prevent emitting a useless event.\\n\\t\\trequire(underlyingAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Increase totalStrategyHoldings to account for the deposit.\\n\\t\\ttotalStrategyHoldings += underlyingAmount;\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// Without this the next harvest would count the deposit as profit.\\n\\t\\t\\t// Cannot overflow as the balance of one strategy can't exceed the sum of all.\\n\\t\\t\\tgetStrategyData[strategy].balance += underlyingAmount.safeCastTo248();\\n\\t\\t}\\n\\n\\t\\temit StrategyDeposit(msg.sender, strategy, underlyingAmount);\\n\\n\\t\\t// We need to deposit differently if the strategy takes ETH.\\n\\t\\tif (strategy.isCEther()) {\\n\\t\\t\\t// Unwrap the right amount of WETH.\\n\\t\\t\\tWETH(payable(address(UNDERLYING))).withdraw(underlyingAmount);\\n\\n\\t\\t\\t// Deposit into the strategy and assume it will revert on error.\\n\\t\\t\\tETHStrategy(address(strategy)).mint{ value: underlyingAmount }();\\n\\t\\t} else {\\n\\t\\t\\t// Approve underlyingAmount to the strategy so we can deposit.\\n\\t\\t\\tUNDERLYING.safeApprove(address(strategy), underlyingAmount);\\n\\n\\t\\t\\t// Deposit into the strategy and revert if it returns an error code.\\n\\t\\t\\trequire(ERC20Strategy(address(strategy)).mint(underlyingAmount) == 0, \\\"MINT_FAILED\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Withdraw a specific amount of underlying tokens from a strategy.\\n\\t/// @param strategy The strategy to withdraw from.\\n\\t/// @param underlyingAmount  The amount of underlying tokens to withdraw.\\n\\t/// @dev Withdrawing from a strategy will not remove it from the withdrawal queue.\\n\\tfunction withdrawFromStrategy(Strategy strategy, uint256 underlyingAmount)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// A strategy must be trusted before it can be withdrawn from.\\n\\t\\trequire(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n\\t\\t// We don't allow withdrawing 0 to prevent emitting a useless event.\\n\\t\\trequire(underlyingAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Without this the next harvest would count the withdrawal as a loss.\\n\\t\\tgetStrategyData[strategy].balance -= underlyingAmount.safeCastTo248();\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// Decrease totalStrategyHoldings to account for the withdrawal.\\n\\t\\t\\t// Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n\\t\\t\\ttotalStrategyHoldings -= underlyingAmount;\\n\\t\\t}\\n\\n\\t\\temit StrategyWithdrawal(msg.sender, strategy, underlyingAmount);\\n\\n\\t\\t// Withdraw from the strategy and revert if it returns an error code.\\n\\t\\trequire(strategy.redeemUnderlying(underlyingAmount) == 0, \\\"REDEEM_FAILED\\\");\\n\\n\\t\\t// Wrap the withdrawn Ether into WETH if necessary.\\n\\t\\tif (strategy.isCEther())\\n\\t\\t\\tWETH(payable(address(UNDERLYING))).deposit{ value: underlyingAmount }();\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                      STRATEGY TRUST/DISTRUST LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when a strategy is set to trusted.\\n\\t/// @param user The authorized user who trusted the strategy.\\n\\t/// @param strategy The strategy that became trusted.\\n\\tevent StrategyTrusted(address indexed user, Strategy indexed strategy);\\n\\n\\t/// @notice Emitted when a strategy is set to untrusted.\\n\\t/// @param user The authorized user who untrusted the strategy.\\n\\t/// @param strategy The strategy that became untrusted.\\n\\tevent StrategyDistrusted(address indexed user, Strategy indexed strategy);\\n\\n\\t/// @notice Stores a strategy as trusted, enabling it to be harvested.\\n\\t/// @param strategy The strategy to make trusted.\\n\\tfunction trustStrategy(Strategy strategy) external requiresAuth {\\n\\t\\t// Ensure the strategy accepts the correct underlying token.\\n\\t\\t// If the strategy accepts ETH the Vault should accept WETH, it'll handle wrapping when necessary.\\n\\t\\trequire(\\n\\t\\t\\tstrategy.isCEther()\\n\\t\\t\\t\\t? underlyingIsWETH\\n\\t\\t\\t\\t: ERC20Strategy(address(strategy)).underlying() == UNDERLYING,\\n\\t\\t\\t\\\"WRONG_UNDERLYING\\\"\\n\\t\\t);\\n\\n\\t\\t// Store the strategy as trusted.\\n\\t\\tgetStrategyData[strategy].trusted = true;\\n\\n\\t\\temit StrategyTrusted(msg.sender, strategy);\\n\\t}\\n\\n\\t/// @notice Stores a strategy as untrusted, disabling it from being harvested.\\n\\t/// @param strategy The strategy to make untrusted.\\n\\tfunction distrustStrategy(Strategy strategy) external requiresAuth {\\n\\t\\t// Store the strategy as untrusted.\\n\\t\\tgetStrategyData[strategy].trusted = false;\\n\\n\\t\\temit StrategyDistrusted(msg.sender, strategy);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                         WITHDRAWAL QUEUE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when a strategy is pushed to the withdrawal queue.\\n\\t/// @param user The authorized user who triggered the push.\\n\\t/// @param pushedStrategy The strategy pushed to the withdrawal queue.\\n\\tevent WithdrawalQueuePushed(address indexed user, Strategy indexed pushedStrategy);\\n\\n\\t/// @notice Emitted when a strategy is popped from the withdrawal queue.\\n\\t/// @param user The authorized user who triggered the pop.\\n\\t/// @param poppedStrategy The strategy popped from the withdrawal queue.\\n\\tevent WithdrawalQueuePopped(address indexed user, Strategy indexed poppedStrategy);\\n\\n\\t/// @notice Emitted when the withdrawal queue is updated.\\n\\t/// @param user The authorized user who triggered the set.\\n\\t/// @param replacedWithdrawalQueue The new withdrawal queue.\\n\\tevent WithdrawalQueueSet(address indexed user, Strategy[] replacedWithdrawalQueue);\\n\\n\\t/// @notice Emitted when an index in the withdrawal queue is replaced.\\n\\t/// @param user The authorized user who triggered the replacement.\\n\\t/// @param index The index of the replaced strategy in the withdrawal queue.\\n\\t/// @param replacedStrategy The strategy in the withdrawal queue that was replaced.\\n\\t/// @param replacementStrategy The strategy that overrode the replaced strategy at the index.\\n\\tevent WithdrawalQueueIndexReplaced(\\n\\t\\taddress indexed user,\\n\\t\\tuint256 index,\\n\\t\\tStrategy indexed replacedStrategy,\\n\\t\\tStrategy indexed replacementStrategy\\n\\t);\\n\\n\\t/// @notice Emitted when an index in the withdrawal queue is replaced with the tip.\\n\\t/// @param user The authorized user who triggered the replacement.\\n\\t/// @param index The index of the replaced strategy in the withdrawal queue.\\n\\t/// @param replacedStrategy The strategy in the withdrawal queue replaced by the tip.\\n\\t/// @param previousTipStrategy The previous tip of the queue that replaced the strategy.\\n\\tevent WithdrawalQueueIndexReplacedWithTip(\\n\\t\\taddress indexed user,\\n\\t\\tuint256 index,\\n\\t\\tStrategy indexed replacedStrategy,\\n\\t\\tStrategy indexed previousTipStrategy\\n\\t);\\n\\n\\t/// @notice Emitted when the strategies at two indexes are swapped.\\n\\t/// @param user The authorized user who triggered the swap.\\n\\t/// @param index1 One index involved in the swap\\n\\t/// @param index2 The other index involved in the swap.\\n\\t/// @param newStrategy1 The strategy (previously at index2) that replaced index1.\\n\\t/// @param newStrategy2 The strategy (previously at index1) that replaced index2.\\n\\tevent WithdrawalQueueIndexesSwapped(\\n\\t\\taddress indexed user,\\n\\t\\tuint256 index1,\\n\\t\\tuint256 index2,\\n\\t\\tStrategy indexed newStrategy1,\\n\\t\\tStrategy indexed newStrategy2\\n\\t);\\n\\n\\t/// @dev Withdraw a specific amount of underlying tokens from strategies in the withdrawal queue.\\n\\t/// @param underlyingAmount The amount of underlying tokens to pull into float.\\n\\t/// @dev Automatically removes depleted strategies from the withdrawal queue.\\n\\tfunction pullFromWithdrawalQueue(uint256 underlyingAmount) internal {\\n\\t\\t// We will update this variable as we pull from strategies.\\n\\t\\tuint256 amountLeftToPull = underlyingAmount;\\n\\n\\t\\t// We'll start at the tip of the queue and traverse backwards.\\n\\t\\tuint256 currentIndex = withdrawalQueue.length - 1;\\n\\n\\t\\t// Iterate in reverse so we pull from the queue in a \\\"last in, first out\\\" manner.\\n\\t\\t// Will revert due to underflow if we empty the queue before pulling the desired amount.\\n\\t\\tfor (; ; currentIndex--) {\\n\\t\\t\\t// Get the strategy at the current queue index.\\n\\t\\t\\tStrategy strategy = withdrawalQueue[currentIndex];\\n\\n\\t\\t\\t// Get the balance of the strategy before we withdraw from it.\\n\\t\\t\\tuint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n\\t\\t\\t// If the strategy is currently untrusted or was already depleted:\\n\\t\\t\\tif (!getStrategyData[strategy].trusted || strategyBalance == 0) {\\n\\t\\t\\t\\t// Remove it from the queue.\\n\\t\\t\\t\\twithdrawalQueue.pop();\\n\\n\\t\\t\\t\\temit WithdrawalQueuePopped(msg.sender, strategy);\\n\\n\\t\\t\\t\\t// Move onto the next strategy.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// We want to pull as much as we can from the strategy, but no more than we need.\\n\\t\\t\\tuint256 amountToPull = FixedPointMathLib.min(amountLeftToPull, strategyBalance);\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t// Compute the balance of the strategy that will remain after we withdraw.\\n\\t\\t\\t\\t// Cannot underflow as we cap the amount to pull at the strategy's balance.\\n\\t\\t\\t\\tuint256 strategyBalanceAfterWithdrawal = strategyBalance - amountToPull;\\n\\n\\t\\t\\t\\t// Without this the next harvest would count the withdrawal as a loss.\\n\\t\\t\\t\\tgetStrategyData[strategy].balance = strategyBalanceAfterWithdrawal.safeCastTo248();\\n\\n\\t\\t\\t\\t// Adjust our goal based on how much we can pull from the strategy.\\n\\t\\t\\t\\t// Cannot underflow as we cap the amount to pull at the amount left to pull.\\n\\t\\t\\t\\tamountLeftToPull -= amountToPull;\\n\\n\\t\\t\\t\\temit StrategyWithdrawal(msg.sender, strategy, amountToPull);\\n\\n\\t\\t\\t\\t// Withdraw from the strategy and revert if returns an error code.\\n\\t\\t\\t\\trequire(strategy.redeemUnderlying(amountToPull) == 0, \\\"REDEEM_FAILED\\\");\\n\\n\\t\\t\\t\\t// If we fully depleted the strategy:\\n\\t\\t\\t\\tif (strategyBalanceAfterWithdrawal == 0) {\\n\\t\\t\\t\\t\\t// Remove it from the queue.\\n\\t\\t\\t\\t\\twithdrawalQueue.pop();\\n\\n\\t\\t\\t\\t\\temit WithdrawalQueuePopped(msg.sender, strategy);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we've pulled all we need, exit the loop.\\n\\t\\t\\tif (amountLeftToPull == 0) break;\\n\\t\\t}\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// Account for the withdrawals done in the loop above.\\n\\t\\t\\t// Cannot underflow as the balances of some strategies cannot exceed the sum of all.\\n\\t\\t\\ttotalStrategyHoldings -= underlyingAmount;\\n\\t\\t}\\n\\n\\t\\t// Cache the Vault's balance of ETH.\\n\\t\\tuint256 ethBalance = address(this).balance;\\n\\n\\t\\t// If the Vault's underlying token is WETH compatible and we have some ETH, wrap it into WETH.\\n\\t\\tif (ethBalance != 0 && underlyingIsWETH)\\n\\t\\t\\tWETH(payable(address(UNDERLYING))).deposit{ value: ethBalance }();\\n\\t}\\n\\n\\t/// @notice Pushes a single strategy to front of the withdrawal queue.\\n\\t/// @param strategy The strategy to be inserted at the front of the withdrawal queue.\\n\\t/// @dev Strategies that are untrusted, duplicated, or have no balance are\\n\\t/// filtered out when encountered at withdrawal time, not validated upfront.\\n\\tfunction pushToWithdrawalQueue(Strategy strategy) external requiresAuth {\\n\\t\\t// Push the strategy to the front of the queue.\\n\\t\\twithdrawalQueue.push(strategy);\\n\\n\\t\\temit WithdrawalQueuePushed(msg.sender, strategy);\\n\\t}\\n\\n\\t/// @notice Removes the strategy at the tip of the withdrawal queue.\\n\\t/// @dev Be careful, another authorized user could push a different strategy\\n\\t/// than expected to the queue while a popFromWithdrawalQueue transaction is pending.\\n\\tfunction popFromWithdrawalQueue() external requiresAuth {\\n\\t\\t// Get the (soon to be) popped strategy.\\n\\t\\tStrategy poppedStrategy = withdrawalQueue[withdrawalQueue.length - 1];\\n\\n\\t\\t// Pop the first strategy in the queue.\\n\\t\\twithdrawalQueue.pop();\\n\\n\\t\\temit WithdrawalQueuePopped(msg.sender, poppedStrategy);\\n\\t}\\n\\n\\t/// @notice Sets a new withdrawal queue.\\n\\t/// @param newQueue The new withdrawal queue.\\n\\t/// @dev Strategies that are untrusted, duplicated, or have no balance are\\n\\t/// filtered out when encountered at withdrawal time, not validated upfront.\\n\\tfunction setWithdrawalQueue(Strategy[] calldata newQueue) external requiresAuth {\\n\\t\\t// Replace the withdrawal queue.\\n\\t\\twithdrawalQueue = newQueue;\\n\\n\\t\\temit WithdrawalQueueSet(msg.sender, newQueue);\\n\\t}\\n\\n\\t/// @notice Replaces an index in the withdrawal queue with another strategy.\\n\\t/// @param index The index in the queue to replace.\\n\\t/// @param replacementStrategy The strategy to override the index with.\\n\\t/// @dev Strategies that are untrusted, duplicated, or have no balance are\\n\\t/// filtered out when encountered at withdrawal time, not validated upfront.\\n\\tfunction replaceWithdrawalQueueIndex(uint256 index, Strategy replacementStrategy)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Get the (soon to be) replaced strategy.\\n\\t\\tStrategy replacedStrategy = withdrawalQueue[index];\\n\\n\\t\\t// Update the index with the replacement strategy.\\n\\t\\twithdrawalQueue[index] = replacementStrategy;\\n\\n\\t\\temit WithdrawalQueueIndexReplaced(msg.sender, index, replacedStrategy, replacementStrategy);\\n\\t}\\n\\n\\t/// @notice Moves the strategy at the tip of the queue to the specified index and pop the tip off the queue.\\n\\t/// @param index The index of the strategy in the withdrawal queue to replace with the tip.\\n\\tfunction replaceWithdrawalQueueIndexWithTip(uint256 index) external requiresAuth {\\n\\t\\t// Get the (soon to be) previous tip and strategy we will replace at the index.\\n\\t\\tStrategy previousTipStrategy = withdrawalQueue[withdrawalQueue.length - 1];\\n\\t\\tStrategy replacedStrategy = withdrawalQueue[index];\\n\\n\\t\\t// Replace the index specified with the tip of the queue.\\n\\t\\twithdrawalQueue[index] = previousTipStrategy;\\n\\n\\t\\t// Remove the now duplicated tip from the array.\\n\\t\\twithdrawalQueue.pop();\\n\\n\\t\\temit WithdrawalQueueIndexReplacedWithTip(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tindex,\\n\\t\\t\\treplacedStrategy,\\n\\t\\t\\tpreviousTipStrategy\\n\\t\\t);\\n\\t}\\n\\n\\t/// @notice Swaps two indexes in the withdrawal queue.\\n\\t/// @param index1 One index involved in the swap\\n\\t/// @param index2 The other index involved in the swap.\\n\\tfunction swapWithdrawalQueueIndexes(uint256 index1, uint256 index2) external requiresAuth {\\n\\t\\t// Get the (soon to be) new strategies at each index.\\n\\t\\tStrategy newStrategy2 = withdrawalQueue[index1];\\n\\t\\tStrategy newStrategy1 = withdrawalQueue[index2];\\n\\n\\t\\t// Swap the strategies at both indexes.\\n\\t\\twithdrawalQueue[index1] = newStrategy1;\\n\\t\\twithdrawalQueue[index2] = newStrategy2;\\n\\n\\t\\temit WithdrawalQueueIndexesSwapped(msg.sender, index1, index2, newStrategy1, newStrategy2);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                         SEIZE STRATEGY LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after a strategy is seized.\\n\\t/// @param user The authorized user who triggered the seize.\\n\\t/// @param strategy The strategy that was seized.\\n\\tevent StrategySeized(address indexed user, Strategy indexed strategy);\\n\\n\\t/// @notice Seizes a strategy.\\n\\t/// @param strategy The strategy to seize.\\n\\t/// @dev Intended for use in emergencies or other extraneous situations where the\\n\\t/// strategy requires interaction outside of the Vault's standard operating procedures.\\n\\tfunction seizeStrategy(Strategy strategy) external requiresAuth {\\n\\t\\t// A strategy must be trusted before it can be seized.\\n\\t\\trequire(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n\\t\\t// Get the strategy's last reported balance of underlying tokens.\\n\\t\\tuint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n\\t\\t// If the strategy's balance exceeds the Vault's current\\n\\t\\t// holdings, instantly unlock any remaining locked profit.\\n\\t\\tif (strategyBalance > totalHoldings()) maxLockedProfit = 0;\\n\\n\\t\\t// Set the strategy's balance to 0.\\n\\t\\tgetStrategyData[strategy].balance = 0;\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// Decrease totalStrategyHoldings to account for the seize.\\n\\t\\t\\t// Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n\\t\\t\\ttotalStrategyHoldings -= strategyBalance;\\n\\t\\t}\\n\\n\\t\\temit StrategySeized(msg.sender, strategy);\\n\\n\\t\\t// Transfer all of the strategy's tokens to the caller.\\n\\t\\tERC20(strategy).safeTransfer(msg.sender, strategy.balanceOf(address(this)));\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                             FEE CLAIM LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after fees are claimed.\\n\\t/// @param user The authorized user who claimed the fees.\\n\\t/// @param rvTokenAmount The amount of rvTokens that were claimed.\\n\\tevent FeesClaimed(address indexed user, uint256 rvTokenAmount);\\n\\n\\t/// @notice Claims fees accrued from harvests.\\n\\t/// @param rvTokenAmount The amount of rvTokens to claim.\\n\\t/// @dev Accrued fees are measured as rvTokens held by the Vault.\\n\\tfunction claimFees(uint256 rvTokenAmount) external requiresAuth {\\n\\t\\temit FeesClaimed(msg.sender, rvTokenAmount);\\n\\n\\t\\t// Transfer the provided amount of rvTokens to the caller.\\n\\t\\tERC20(this).safeTransfer(msg.sender, rvTokenAmount);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                    INITIALIZATION AND DESTRUCTION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when the Vault is initialized.\\n\\t/// @param user The authorized user who triggered the initialization.\\n\\tevent Initialized(address indexed user);\\n\\n\\t/// @notice Whether the Vault has been initialized yet.\\n\\t/// @dev Can go from false to true, never from true to false.\\n\\tbool public isInitialized;\\n\\n\\t/// @notice Initializes the Vault, enabling it to receive deposits.\\n\\t/// @dev All critical parameters must already be set before calling.\\n\\tfunction initialize() external requiresAuth {\\n\\t\\t// Ensure the Vault has not already been initialized.\\n\\t\\trequire(!isInitialized, \\\"ALREADY_INITIALIZED\\\");\\n\\n\\t\\t// Mark the Vault as initialized.\\n\\t\\tisInitialized = true;\\n\\n\\t\\t// Open for deposits.\\n\\t\\ttotalSupply = 0;\\n\\n\\t\\temit Initialized(msg.sender);\\n\\t}\\n\\n\\t/// @notice Self destructs a Vault, enabling it to be redeployed.\\n\\t/// @dev Caller will receive any ETH held as float in the Vault.\\n\\tfunction destroy() external requiresAuth {\\n\\t\\tselfdestruct(payable(msg.sender));\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                          RECIEVE ETHER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @dev Required for the Vault to receive unwrapped ETH.\\n\\treceive() external payable {}\\n}\\n\",\"keccak256\":\"0x9edb7b5020282788b8ca68d7523c3b3b0d49bf68b584517d01992feec52a72ef\",\"license\":\"AGPL-3.0\"},\"src/vault/VaultFactory.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\nimport { Auth, Authority } from \\\"solmate/src/auth/Auth.sol\\\";\\nimport { Bytes32AddressLib } from \\\"solmate/src/utils/Bytes32AddressLib.sol\\\";\\n\\nimport { Vault } from \\\"./Vault.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title Rari Vault Factory\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Factory which enables deploying a Vault for any ERC20 token.\\ncontract VaultFactory is Auth {\\n\\tusing Bytes32AddressLib for address;\\n\\tusing Bytes32AddressLib for bytes32;\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Creates a Vault factory.\\n\\t/// @param _owner The owner of the factory.\\n\\t/// @param _authority The Authority of the factory.\\n\\tconstructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                          VAULT DEPLOYMENT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when a new Vault is deployed.\\n\\t/// @param vault The newly deployed Vault contract.\\n\\t/// @param underlying The underlying token the new Vault accepts.\\n\\tevent VaultDeployed(Vault vault, ERC20 underlying);\\n\\n\\t/// @notice Deploys a new Vault which supports a specific underlying token.\\n\\t/// @dev This will revert if a Vault that accepts the same underlying token has already been deployed.\\n\\t/// @param underlying The ERC20 token that the Vault should accept.\\n\\t/// @param id We may have different vaults w different credit ratings for the same asset\\n\\t/// @return vault The newly deployed Vault contract which accepts the provided underlying token.\\n\\tfunction deployVault(ERC20 underlying, uint256 id) external returns (Vault vault) {\\n\\t\\t// Use the CREATE2 opcode to deploy a new Vault contract.\\n\\t\\t// This will revert if a Vault which accepts this underlying token has already\\n\\t\\t// been deployed, as the salt would be the same and we can't deploy with it twice.\\n\\t\\tvault = new Vault{ salt: address(underlying).fillLast12Bytes() | bytes32(id) }(underlying);\\n\\n\\t\\temit VaultDeployed(vault, underlying);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                            VAULT LOOKUP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Computes a Vault's address from its accepted underlying token.\\n\\t/// @param underlying The ERC20 token that the Vault should accept.\\n\\t/// @param id We may have different vaults w different credit ratings for the same asset\\n\\t/// @return The address of a Vault which accepts the provided underlying token.\\n\\t/// @dev The Vault returned may not be deployed yet. Use isVaultDeployed to check.\\n\\tfunction getVaultFromUnderlying(ERC20 underlying, uint256 id) external view returns (Vault) {\\n\\t\\treturn\\n\\t\\t\\tVault(\\n\\t\\t\\t\\tpayable(\\n\\t\\t\\t\\t\\tkeccak256(\\n\\t\\t\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\t\\t// Prefix:\\n\\t\\t\\t\\t\\t\\t\\tbytes1(0xFF),\\n\\t\\t\\t\\t\\t\\t\\t// Creator:\\n\\t\\t\\t\\t\\t\\t\\taddress(this),\\n\\t\\t\\t\\t\\t\\t\\t// Salt:\\n\\t\\t\\t\\t\\t\\t\\taddress(underlying).fillLast12Bytes() | bytes32(id),\\n\\t\\t\\t\\t\\t\\t\\t// Bytecode hash:\\n\\t\\t\\t\\t\\t\\t\\tkeccak256(\\n\\t\\t\\t\\t\\t\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Deployment bytecode:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ttype(Vault).creationCode,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// Constructor arguments:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tabi.encode(underlying)\\n\\t\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t\\t)\\n\\t\\t\\t\\t\\t).fromLast20Bytes() // Convert the CREATE2 hash into an address.\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t}\\n\\n\\t/// @notice Returns if a Vault at an address has already been deployed.\\n\\t/// @param vault The address of a Vault which may not have been deployed yet.\\n\\t/// @return A boolean indicating whether the Vault has been deployed already.\\n\\t/// @dev This function is useful to check the return values of getVaultFromUnderlying,\\n\\t/// as it does not check that the Vault addresses it computes have been deployed yet.\\n\\tfunction isVaultDeployed(Vault vault) external view returns (bool) {\\n\\t\\treturn address(vault).code.length > 0;\\n\\t}\\n}\\n\",\"keccak256\":\"0x9585913f2ee8c73abca14bfa2f1e6fb61eb4200cc630f65ec1ff3c09a01da35f\",\"license\":\"AGPL-3.0\"},\"src/vault/interfaces/Strategy.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\n/// @dev Designed for out of the box compatibility with Fuse cTokens.\\n/// @dev Like cTokens, strategies must be transferrable ERC20s.\\nabstract contract Strategy is ERC20 {\\n\\t/// @notice Returns whether the strategy accepts ETH or an ERC20.\\n\\t/// @return True if the strategy accepts ETH, false otherwise.\\n\\t/// @dev Only present in Fuse cTokens, not Compound cTokens.\\n\\tfunction isCEther() external view virtual returns (bool);\\n\\n\\t/// @notice Withdraws a specific amount of underlying tokens from the strategy.\\n\\t/// @param amount The amount of underlying tokens to withdraw.\\n\\t/// @return An error code, or 0 if the withdrawal was successful.\\n\\tfunction redeemUnderlying(uint256 amount) external virtual returns (uint256);\\n\\n\\t/// @notice Returns a user's strategy balance in underlying tokens.\\n\\t/// @param user The user to get the underlying balance of.\\n\\t/// @return The user's strategy balance in underlying tokens.\\n\\t/// @dev May mutate the state of the strategy by accruing interest.\\n\\tfunction balanceOfUnderlying(address user) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ERC20s.\\n/// @dev Designed for out of the box compatibility with Fuse cERC20s.\\nabstract contract ERC20Strategy is Strategy {\\n\\t/// @notice Returns the underlying ERC20 token the strategy accepts.\\n\\t/// @return The underlying ERC20 token the strategy accepts.\\n\\tfunction underlying() external view virtual returns (ERC20);\\n\\n\\t/// @notice Deposit a specific amount of underlying tokens into the strategy.\\n\\t/// @param amount The amount of underlying tokens to deposit.\\n\\t/// @return An error code, or 0 if the deposit was successful.\\n\\tfunction mint(uint256 amount) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ETH.\\n/// @dev Designed for out of the box compatibility with Fuse cEther.\\nabstract contract ETHStrategy is Strategy {\\n\\t/// @notice Deposit a specific amount of ETH into the strategy.\\n\\t/// @dev The amount of ETH is specified via msg.value. Reverts on error.\\n\\tfunction mint() external payable virtual;\\n}\\n\",\"keccak256\":\"0xd4d9b8156bf24e60585bdd7e74e7f343a59440fa73b18d7b46b1b80e585f39c6\",\"license\":\"AGPL-3.0\"},\"src/vault/modules/VaultConfigurationModule.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\nimport { Auth, Authority } from \\\"solmate/src/auth/Auth.sol\\\";\\n\\nimport { Vault } from \\\"../Vault.sol\\\";\\n\\n/// @title Rari Vault Configuration Module\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Module for configuring Vault parameters.\\ncontract VaultConfigurationModule is Auth {\\n\\t/*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Creates a Vault configuration module.\\n\\t/// @param _owner The owner of the module.\\n\\t/// @param _authority The Authority of the module.\\n\\tconstructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                  DEFAULT VAULT PARAMETER CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when the default fee percentage is updated.\\n\\t/// @param newDefaultFeePercent The new default fee percentage.\\n\\tevent DefaultFeePercentUpdated(uint256 newDefaultFeePercent);\\n\\n\\t/// @notice Emitted when the default harvest delay is updated.\\n\\t/// @param newDefaultHarvestDelay The new default harvest delay.\\n\\tevent DefaultHarvestDelayUpdated(uint64 newDefaultHarvestDelay);\\n\\n\\t/// @notice Emitted when the default harvest window is updated.\\n\\t/// @param newDefaultHarvestWindow The new default harvest window.\\n\\tevent DefaultHarvestWindowUpdated(uint128 newDefaultHarvestWindow);\\n\\n\\t/// @notice Emitted when the default target float percentage is updated.\\n\\t/// @param newDefaultTargetFloatPercent The new default target float percentage.\\n\\tevent DefaultTargetFloatPercentUpdated(uint256 newDefaultTargetFloatPercent);\\n\\n\\t/// @notice The default fee percentage for Vaults.\\n\\tuint256 public defaultFeePercent;\\n\\n\\t/// @notice The default harvest delay for Vaults.\\n\\tuint64 public defaultHarvestDelay;\\n\\n\\t/// @notice The default harvest window for Vaults.\\n\\tuint128 public defaultHarvestWindow;\\n\\n\\t/// @notice The default target float percentage for Vaults.\\n\\tuint256 public defaultTargetFloatPercent;\\n\\n\\t/// @notice Sets the default fee percentage for Vaults.\\n\\t/// @param newDefaultFeePercent The new default fee percentage to set.\\n\\tfunction setDefaultFeePercent(uint256 newDefaultFeePercent) external requiresAuth {\\n\\t\\t// Update the default fee percentage.\\n\\t\\tdefaultFeePercent = newDefaultFeePercent;\\n\\n\\t\\temit DefaultFeePercentUpdated(newDefaultFeePercent);\\n\\t}\\n\\n\\t/// @notice Sets the default harvest delay for Vaults.\\n\\t/// @param newDefaultHarvestDelay The new default harvest delay to set.\\n\\tfunction setDefaultHarvestDelay(uint64 newDefaultHarvestDelay) external requiresAuth {\\n\\t\\t// Update the default harvest delay.\\n\\t\\tdefaultHarvestDelay = newDefaultHarvestDelay;\\n\\n\\t\\temit DefaultHarvestDelayUpdated(newDefaultHarvestDelay);\\n\\t}\\n\\n\\t/// @notice Sets the default harvest window for Vaults.\\n\\t/// @param newDefaultHarvestWindow The new default harvest window to set.\\n\\tfunction setDefaultHarvestWindow(uint128 newDefaultHarvestWindow) external requiresAuth {\\n\\t\\t// Update the default harvest window.\\n\\t\\tdefaultHarvestWindow = newDefaultHarvestWindow;\\n\\n\\t\\temit DefaultHarvestWindowUpdated(newDefaultHarvestWindow);\\n\\t}\\n\\n\\t/// @notice Sets the default target float percentage for Vaults.\\n\\t/// @param newDefaultTargetFloatPercent The new default target float percentage to set.\\n\\tfunction setDefaultTargetFloatPercent(uint256 newDefaultTargetFloatPercent)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Update the default target float percentage.\\n\\t\\tdefaultTargetFloatPercent = newDefaultTargetFloatPercent;\\n\\n\\t\\temit DefaultTargetFloatPercentUpdated(newDefaultTargetFloatPercent);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                  CUSTOM VAULT PARAMETER CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when a Vault has its custom fee percentage set/updated.\\n\\t/// @param vault The Vault that had its custom fee percentage set/updated.\\n\\t/// @param newCustomFeePercent The new custom fee percentage for the Vault.\\n\\tevent CustomFeePercentUpdated(Vault indexed vault, uint256 newCustomFeePercent);\\n\\n\\t/// @notice Emitted when a Vault has its custom harvest delay set/updated.\\n\\t/// @param vault The Vault that had its custom harvest delay set/updated.\\n\\t/// @param newCustomHarvestDelay The new custom harvest delay for the Vault.\\n\\tevent CustomHarvestDelayUpdated(Vault indexed vault, uint256 newCustomHarvestDelay);\\n\\n\\t/// @notice Emitted when a Vault has its custom harvest window set/updated.\\n\\t/// @param vault The Vault that had its custom harvest window set/updated.\\n\\t/// @param newCustomHarvestWindow The new custom harvest window for the Vault.\\n\\tevent CustomHarvestWindowUpdated(Vault indexed vault, uint256 newCustomHarvestWindow);\\n\\n\\t/// @notice Emitted when a Vault has its custom target float percentage set/updated.\\n\\t/// @param vault The Vault that had its custom target float percentage set/updated.\\n\\t/// @param newCustomTargetFloatPercent The new custom target float percentage for the Vault.\\n\\tevent CustomTargetFloatPercentUpdated(Vault indexed vault, uint256 newCustomTargetFloatPercent);\\n\\n\\t/// @notice Maps Vaults to their custom fee percentage.\\n\\t/// @dev Will be 0 if there is no custom fee percentage for the Vault.\\n\\tmapping(Vault => uint256) public getVaultCustomFeePercent;\\n\\n\\t/// @notice Maps Vaults to their custom harvest delay.\\n\\t/// @dev Will be 0 if there is no custom harvest delay for the Vault.\\n\\tmapping(Vault => uint64) public getVaultCustomHarvestDelay;\\n\\n\\t/// @notice Maps Vaults to their custom harvest window.\\n\\t/// @dev Will be 0 if there is no custom harvest window for the Vault.\\n\\tmapping(Vault => uint128) public getVaultCustomHarvestWindow;\\n\\n\\t/// @notice Maps Vaults to their custom target float percentage.\\n\\t/// @dev Will be 0 if there is no custom target float percentage for the Vault.\\n\\tmapping(Vault => uint256) public getVaultCustomTargetFloatPercent;\\n\\n\\t/// @notice Sets the custom fee percentage for the Vault.\\n\\t/// @param vault The Vault to set the custom fee percentage for.\\n\\t/// @param customFeePercent The new custom fee percentage to set.\\n\\tfunction setVaultCustomFeePercent(Vault vault, uint256 customFeePercent) external requiresAuth {\\n\\t\\t// Update the Vault's custom fee percentage.\\n\\t\\tgetVaultCustomFeePercent[vault] = customFeePercent;\\n\\n\\t\\temit CustomFeePercentUpdated(vault, customFeePercent);\\n\\t}\\n\\n\\t/// @notice Sets the custom harvest delay for the Vault.\\n\\t/// @param vault The Vault to set the custom harvest delay for.\\n\\t/// @param customHarvestDelay The new custom harvest delay to set.\\n\\tfunction setVaultCustomHarvestDelay(Vault vault, uint64 customHarvestDelay)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Update the Vault's custom harvest delay.\\n\\t\\tgetVaultCustomHarvestDelay[vault] = customHarvestDelay;\\n\\n\\t\\temit CustomHarvestDelayUpdated(vault, customHarvestDelay);\\n\\t}\\n\\n\\t/// @notice Sets the custom harvest window for the Vault.\\n\\t/// @param vault The Vault to set the custom harvest window for.\\n\\t/// @param customHarvestWindow The new custom harvest window to set.\\n\\tfunction setVaultCustomHarvestWindow(Vault vault, uint128 customHarvestWindow)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Update the Vault's custom harvest window.\\n\\t\\tgetVaultCustomHarvestWindow[vault] = customHarvestWindow;\\n\\n\\t\\temit CustomHarvestWindowUpdated(vault, customHarvestWindow);\\n\\t}\\n\\n\\t/// @notice Sets the custom target float percentage for the Vault.\\n\\t/// @param vault The Vault to set the custom target float percentage for.\\n\\t/// @param customTargetFloatPercent The new custom target float percentage to set.\\n\\tfunction setVaultCustomTargetFloatPercent(Vault vault, uint256 customTargetFloatPercent)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Update the Vault's custom target float percentage.\\n\\t\\tgetVaultCustomTargetFloatPercent[vault] = customTargetFloatPercent;\\n\\n\\t\\temit CustomTargetFloatPercentUpdated(vault, customTargetFloatPercent);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                       VAULT PARAMETER SYNC LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Syncs a Vault's fee percentage with either the Vault's custom fee\\n\\t/// percentage or the default fee percentage if a custom percentage is not set.\\n\\t/// @param vault The Vault to sync the fee percentage for.\\n\\tfunction syncFeePercent(Vault vault) external {\\n\\t\\t// Get the Vault's custom fee percentage.\\n\\t\\tuint256 customFeePercent = getVaultCustomFeePercent[vault];\\n\\n\\t\\t// Set the Vault's fee percentage to the custom fee percentage\\n\\t\\t// or the default fee percentage if a custom percentage isn't set.\\n\\t\\tvault.setFeePercent(customFeePercent == 0 ? defaultFeePercent : customFeePercent);\\n\\t}\\n\\n\\t/// @notice Syncs a Vault's harvest delay with either the Vault's custom\\n\\t/// harvest delay or the default harvest delay if a custom delay is not set.\\n\\t/// @param vault The Vault to sync the harvest delay for.\\n\\tfunction syncHarvestDelay(Vault vault) external {\\n\\t\\t// Get the Vault's custom harvest delay.\\n\\t\\tuint64 customHarvestDelay = getVaultCustomHarvestDelay[vault];\\n\\n\\t\\t// Set the Vault's harvest delay to the custom harvest delay\\n\\t\\t// or the default harvest delay if a custom delay isn't set.\\n\\t\\tvault.setHarvestDelay(customHarvestDelay == 0 ? defaultHarvestDelay : customHarvestDelay);\\n\\t}\\n\\n\\t/// @notice Syncs a Vault's harvest window with either the Vault's custom\\n\\t/// harvest window or the default harvest window if a custom window is not set.\\n\\t/// @param vault The Vault to sync the harvest window for.\\n\\tfunction syncHarvestWindow(Vault vault) external {\\n\\t\\t// Get the Vault's custom harvest window.\\n\\t\\tuint128 customHarvestWindow = getVaultCustomHarvestWindow[vault];\\n\\n\\t\\t// Set the Vault's harvest window to the custom harvest window\\n\\t\\t// or the default harvest window if a custom window isn't set.\\n\\t\\tvault.setHarvestWindow(\\n\\t\\t\\tcustomHarvestWindow == 0 ? defaultHarvestWindow : customHarvestWindow\\n\\t\\t);\\n\\t}\\n\\n\\t/// @notice Syncs a Vault's target float percentage with either the Vault's custom target\\n\\t/// float percentage or the default target float percentage if a custom percentage is not set.\\n\\t/// @param vault The Vault to sync the target float percentage for.\\n\\tfunction syncTargetFloatPercent(Vault vault) external {\\n\\t\\t// Get the Vault's custom target float percentage.\\n\\t\\tuint256 customTargetFloatPercent = getVaultCustomTargetFloatPercent[vault];\\n\\n\\t\\t// Set the Vault's target float percentage to the custom target float percentage\\n\\t\\t// or the default target float percentage if a custom percentage isn't set.\\n\\t\\tvault.setTargetFloatPercent(\\n\\t\\t\\tcustomTargetFloatPercent == 0 ? defaultTargetFloatPercent : customTargetFloatPercent\\n\\t\\t);\\n\\t}\\n}\\n\",\"keccak256\":\"0x1ed2b6021ae3e5a4d49461f88ae7db0d4846e639c2af868168aaed00df4bc4d4\",\"license\":\"AGPL-3.0\"},\"src/vault/modules/VaultInitializationModule.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\nimport { Auth, Authority } from \\\"solmate/src/auth/Auth.sol\\\";\\n\\nimport { Vault } from \\\"../Vault.sol\\\";\\nimport { VaultFactory } from \\\"../VaultFactory.sol\\\";\\n\\nimport { VaultConfigurationModule } from \\\"./VaultConfigurationModule.sol\\\";\\n\\n/// @title Rari Vault Initialization Module\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Module for initializing newly created Vaults.\\ncontract VaultInitializationModule is Auth {\\n\\t/// @notice Vault configuration module used to configure Vaults before initialization.\\n\\tVaultConfigurationModule public configModule;\\n\\n\\t/// @notice Creates a Vault initialization module.\\n\\t/// @param _configModule The Vault configuration module the\\n\\t/// module will use to configure Vaults before initialization.\\n\\t/// @param _owner The owner of the module.\\n\\t/// @param _authority The Authority of the module.\\n\\tconstructor(\\n\\t\\tVaultConfigurationModule _configModule,\\n\\t\\taddress _owner,\\n\\t\\tAuthority _authority\\n\\t) Auth(_owner, _authority) {\\n\\t\\tconfigModule = _configModule;\\n\\t}\\n\\n\\t/// @notice Emitted when the config module is updated.\\n\\t/// @param newConfigModule The new configuration module.\\n\\tevent ConfigModuleUpdated(VaultConfigurationModule newConfigModule);\\n\\n\\t/// @notice Sets a new Vault configuration module.\\n\\t/// @param newConfigModule The Vault configuration module to set.\\n\\tfunction setConfigModule(VaultConfigurationModule newConfigModule) external requiresAuth {\\n\\t\\t// Update the config module.\\n\\t\\tconfigModule = newConfigModule;\\n\\n\\t\\temit ConfigModuleUpdated(newConfigModule);\\n\\t}\\n\\n\\t/// @notice Properly configures and initializes a newly deployed Vault.\\n\\t/// @dev This will revert if the Vault has already been initialized.\\n\\t/// @param vault The Vault to configure and initialize.\\n\\tfunction initializeVault(Vault vault) external {\\n\\t\\t// Configure all key parameters.\\n\\t\\tconfigModule.syncFeePercent(vault);\\n\\t\\tconfigModule.syncHarvestDelay(vault);\\n\\t\\tconfigModule.syncHarvestWindow(vault);\\n\\t\\tconfigModule.syncTargetFloatPercent(vault);\\n\\n\\t\\t// Open the Vault up for deposits.\\n\\t\\tvault.initialize();\\n\\t}\\n}\\n\",\"keccak256\":\"0x1e8b4e9b145b9ceaa01467a53b127f7f9dddacaa1fb6fa5dc540d947e8d9819e\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5060405161076138038061076183398101604081905261002f91610100565b600080546001600160a01b03199081166001600160a01b038581169182178455600180549093169085161790915560405184928492917f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b9190a26040516001600160a01b038216907f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a25050600280546001600160a01b0319166001600160a01b0394909416939093179092555061014d9050565b6001600160a01b03811681146100fd57600080fd5b50565b60008060006060848603121561011557600080fd5b8351610120816100e8565b6020850151909350610131816100e8565b6040850151909250610142816100e8565b809150509250925092565b6106058061015c6000396000f3fe608060405234801561001057600080fd5b506004361061006d5760003560e01c806313af40351461007257806368f1e99a146100875780637a9e5e4b146100b05780638da5cb5b146100c3578063ad9ab820146100d6578063bf7e214f146100e9578063ccb6a270146100fc575b600080fd5b61008561008036600461054f565b61010f565b005b60025461009a906001600160a01b031681565b6040516100a79190610573565b60405180910390f35b6100856100be36600461054f565b610192565b60005461009a906001600160a01b031681565b6100856100e436600461054f565b61020e565b60015461009a906001600160a01b031681565b61008561010a36600461054f565b610296565b610125336000356001600160e01b031916610474565b61014a5760405162461bcd60e51b815260040161014190610587565b60405180910390fd5b600080546001600160a01b0319166001600160a01b038316908117825560405190917f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b91a250565b6101a8336000356001600160e01b031916610474565b6101c45760405162461bcd60e51b815260040161014190610587565b600180546001600160a01b0319166001600160a01b0383169081179091556040517f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250565b610224336000356001600160e01b031916610474565b6102405760405162461bcd60e51b815260040161014190610587565b600280546001600160a01b0319166001600160a01b0383161790556040517fcc0bfba2fd41fad8e74708649f00db8723ef3361e1e43460f586cf04378035cd9061028b908390610573565b60405180910390a150565b6002546040516316f8725960e31b81526001600160a01b039091169063b7c392c8906102c6908490600401610573565b600060405180830381600087803b1580156102e057600080fd5b505af11580156102f4573d6000803e3d6000fd5b5050600254604051635607702f60e01b81526001600160a01b039091169250635607702f9150610328908490600401610573565b600060405180830381600087803b15801561034257600080fd5b505af1158015610356573d6000803e3d6000fd5b505060025460405163e7d9934b60e01b81526001600160a01b03909116925063e7d9934b915061038a908490600401610573565b600060405180830381600087803b1580156103a457600080fd5b505af11580156103b8573d6000803e3d6000fd5b505060025460405163ac345d0360e01b81526001600160a01b03909116925063ac345d0391506103ec908490600401610573565b600060405180830381600087803b15801561040657600080fd5b505af115801561041a573d6000803e3d6000fd5b50505050806001600160a01b0316638129fc1c6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561045957600080fd5b505af115801561046d573d6000803e3d6000fd5b5050505050565b6001546000906001600160a01b0316801561051d5760405163b700961360e01b81526001600160a01b0385811660048301523060248301526001600160e01b03198516604483015282169063b700961390606401602060405180830381865afa925050508015610501575060408051601f3d908101601f191682019092526104fe918101906105ad565b60015b61050a5761051d565b801561051b57600192505050610531565b505b50506000546001600160a01b038381169116145b92915050565b6001600160a01b038116811461054c57600080fd5b50565b60006020828403121561056157600080fd5b813561056c81610537565b9392505050565b6001600160a01b0391909116815260200190565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b6000602082840312156105bf57600080fd5b8151801515811461056c57600080fdfea2646970667358221220647c106a387a49a519d20abcd6826c782300a80220c4ac1a1294bbcc31417e4064736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061006d5760003560e01c806313af40351461007257806368f1e99a146100875780637a9e5e4b146100b05780638da5cb5b146100c3578063ad9ab820146100d6578063bf7e214f146100e9578063ccb6a270146100fc575b600080fd5b61008561008036600461054f565b61010f565b005b60025461009a906001600160a01b031681565b6040516100a79190610573565b60405180910390f35b6100856100be36600461054f565b610192565b60005461009a906001600160a01b031681565b6100856100e436600461054f565b61020e565b60015461009a906001600160a01b031681565b61008561010a36600461054f565b610296565b610125336000356001600160e01b031916610474565b61014a5760405162461bcd60e51b815260040161014190610587565b60405180910390fd5b600080546001600160a01b0319166001600160a01b038316908117825560405190917f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b91a250565b6101a8336000356001600160e01b031916610474565b6101c45760405162461bcd60e51b815260040161014190610587565b600180546001600160a01b0319166001600160a01b0383169081179091556040517f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250565b610224336000356001600160e01b031916610474565b6102405760405162461bcd60e51b815260040161014190610587565b600280546001600160a01b0319166001600160a01b0383161790556040517fcc0bfba2fd41fad8e74708649f00db8723ef3361e1e43460f586cf04378035cd9061028b908390610573565b60405180910390a150565b6002546040516316f8725960e31b81526001600160a01b039091169063b7c392c8906102c6908490600401610573565b600060405180830381600087803b1580156102e057600080fd5b505af11580156102f4573d6000803e3d6000fd5b5050600254604051635607702f60e01b81526001600160a01b039091169250635607702f9150610328908490600401610573565b600060405180830381600087803b15801561034257600080fd5b505af1158015610356573d6000803e3d6000fd5b505060025460405163e7d9934b60e01b81526001600160a01b03909116925063e7d9934b915061038a908490600401610573565b600060405180830381600087803b1580156103a457600080fd5b505af11580156103b8573d6000803e3d6000fd5b505060025460405163ac345d0360e01b81526001600160a01b03909116925063ac345d0391506103ec908490600401610573565b600060405180830381600087803b15801561040657600080fd5b505af115801561041a573d6000803e3d6000fd5b50505050806001600160a01b0316638129fc1c6040518163ffffffff1660e01b8152600401600060405180830381600087803b15801561045957600080fd5b505af115801561046d573d6000803e3d6000fd5b5050505050565b6001546000906001600160a01b0316801561051d5760405163b700961360e01b81526001600160a01b0385811660048301523060248301526001600160e01b03198516604483015282169063b700961390606401602060405180830381865afa925050508015610501575060408051601f3d908101601f191682019092526104fe918101906105ad565b60015b61050a5761051d565b801561051b57600192505050610531565b505b50506000546001600160a01b038381169116145b92915050565b6001600160a01b038116811461054c57600080fd5b50565b60006020828403121561056157600080fd5b813561056c81610537565b9392505050565b6001600160a01b0391909116815260200190565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b6000602082840312156105bf57600080fd5b8151801515811461056c57600080fdfea2646970667358221220647c106a387a49a519d20abcd6826c782300a80220c4ac1a1294bbcc31417e4064736f6c634300080a0033",
  "devdoc": {
    "author": "Transmissions11 and JetJadeja",
    "events": {
      "ConfigModuleUpdated(address)": {
        "params": {
          "newConfigModule": "The new configuration module."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_authority": "The Authority of the module.",
          "_configModule": "The Vault configuration module the module will use to configure Vaults before initialization.",
          "_owner": "The owner of the module."
        }
      },
      "initializeVault(address)": {
        "details": "This will revert if the Vault has already been initialized.",
        "params": {
          "vault": "The Vault to configure and initialize."
        }
      },
      "setConfigModule(address)": {
        "params": {
          "newConfigModule": "The Vault configuration module to set."
        }
      }
    },
    "title": "Rari Vault Initialization Module",
    "version": 1
  },
  "userdoc": {
    "events": {
      "ConfigModuleUpdated(address)": {
        "notice": "Emitted when the config module is updated."
      }
    },
    "kind": "user",
    "methods": {
      "configModule()": {
        "notice": "Vault configuration module used to configure Vaults before initialization."
      },
      "constructor": {
        "notice": "Creates a Vault initialization module."
      },
      "initializeVault(address)": {
        "notice": "Properly configures and initializes a newly deployed Vault."
      },
      "setConfigModule(address)": {
        "notice": "Sets a new Vault configuration module."
      }
    },
    "notice": "Module for initializing newly created Vaults.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 9760,
        "contract": "src/vault/modules/VaultInitializationModule.sol:VaultInitializationModule",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 9763,
        "contract": "src/vault/modules/VaultInitializationModule.sol:VaultInitializationModule",
        "label": "authority",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Authority)9748"
      },
      {
        "astId": 18650,
        "contract": "src/vault/modules/VaultInitializationModule.sol:VaultInitializationModule",
        "label": "configModule",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(VaultConfigurationModule)18630"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(Authority)9748": {
        "encoding": "inplace",
        "label": "contract Authority",
        "numberOfBytes": "20"
      },
      "t_contract(VaultConfigurationModule)18630": {
        "encoding": "inplace",
        "label": "contract VaultConfigurationModule",
        "numberOfBytes": "20"
      }
    }
  }
}
