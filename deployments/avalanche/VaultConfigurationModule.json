{
  "address": "0x5672E5aCbBbb467Feaf91327C847824Dd1C4f4B9",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "contract Authority",
          "name": "_authority",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Authority",
          "name": "authority",
          "type": "address"
        }
      ],
      "name": "AuthorityUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCustomFeePercent",
          "type": "uint256"
        }
      ],
      "name": "CustomFeePercentUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCustomHarvestDelay",
          "type": "uint256"
        }
      ],
      "name": "CustomHarvestDelayUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCustomHarvestWindow",
          "type": "uint256"
        }
      ],
      "name": "CustomHarvestWindowUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newCustomTargetFloatPercent",
          "type": "uint256"
        }
      ],
      "name": "CustomTargetFloatPercentUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newDefaultFeePercent",
          "type": "uint256"
        }
      ],
      "name": "DefaultFeePercentUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint64",
          "name": "newDefaultHarvestDelay",
          "type": "uint64"
        }
      ],
      "name": "DefaultHarvestDelayUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint128",
          "name": "newDefaultHarvestWindow",
          "type": "uint128"
        }
      ],
      "name": "DefaultHarvestWindowUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "newDefaultTargetFloatPercent",
          "type": "uint256"
        }
      ],
      "name": "DefaultTargetFloatPercentUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "OwnerUpdated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "authority",
      "outputs": [
        {
          "internalType": "contract Authority",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultFeePercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultHarvestDelay",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultHarvestWindow",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "defaultTargetFloatPercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "name": "getVaultCustomFeePercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "name": "getVaultCustomHarvestDelay",
      "outputs": [
        {
          "internalType": "uint64",
          "name": "",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "name": "getVaultCustomHarvestWindow",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "",
          "type": "address"
        }
      ],
      "name": "getVaultCustomTargetFloatPercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Authority",
          "name": "newAuthority",
          "type": "address"
        }
      ],
      "name": "setAuthority",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newDefaultFeePercent",
          "type": "uint256"
        }
      ],
      "name": "setDefaultFeePercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "newDefaultHarvestDelay",
          "type": "uint64"
        }
      ],
      "name": "setDefaultHarvestDelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint128",
          "name": "newDefaultHarvestWindow",
          "type": "uint128"
        }
      ],
      "name": "setDefaultHarvestWindow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "newDefaultTargetFloatPercent",
          "type": "uint256"
        }
      ],
      "name": "setDefaultTargetFloatPercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "setOwner",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "customFeePercent",
          "type": "uint256"
        }
      ],
      "name": "setVaultCustomFeePercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "customHarvestDelay",
          "type": "uint64"
        }
      ],
      "name": "setVaultCustomHarvestDelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint128",
          "name": "customHarvestWindow",
          "type": "uint128"
        }
      ],
      "name": "setVaultCustomHarvestWindow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "customTargetFloatPercent",
          "type": "uint256"
        }
      ],
      "name": "setVaultCustomTargetFloatPercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "syncFeePercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "syncHarvestDelay",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "syncHarvestWindow",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract Vault",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "syncTargetFloatPercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x43c2826d836e10551882d2ee36e2421088b31136747e7ba111234ae2f78c072e",
  "receipt": {
    "to": null,
    "from": "0xf09c27934A92c56c7C0dD6cBAc858C35fBd5170f",
    "contractAddress": "0x5672E5aCbBbb467Feaf91327C847824Dd1C4f4B9",
    "transactionIndex": 35,
    "gasUsed": "811021",
    "logsBloom": "0x00000000000000000000000020000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000008000000000000000000000000000080000000000000000000000000000000000000001000000020000000000002000000000000000000000008100000200000000000000000000000000000000200000000000000000000000008000000000000000000000000000000000000000000",
    "blockHash": "0x01b42f7463dcf332d042df2d633d21258557477ab2a2dccc70f4876d59f2f012",
    "transactionHash": "0x43c2826d836e10551882d2ee36e2421088b31136747e7ba111234ae2f78c072e",
    "logs": [
      {
        "transactionIndex": 35,
        "blockNumber": 8370660,
        "transactionHash": "0x43c2826d836e10551882d2ee36e2421088b31136747e7ba111234ae2f78c072e",
        "address": "0x5672E5aCbBbb467Feaf91327C847824Dd1C4f4B9",
        "topics": [
          "0x4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b",
          "0x000000000000000000000000f09c27934a92c56c7c0dd6cbac858c35fbd5170f"
        ],
        "data": "0x",
        "logIndex": 201,
        "blockHash": "0x01b42f7463dcf332d042df2d633d21258557477ab2a2dccc70f4876d59f2f012"
      },
      {
        "transactionIndex": 35,
        "blockNumber": 8370660,
        "transactionHash": "0x43c2826d836e10551882d2ee36e2421088b31136747e7ba111234ae2f78c072e",
        "address": "0x5672E5aCbBbb467Feaf91327C847824Dd1C4f4B9",
        "topics": [
          "0x2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad",
          "0x000000000000000000000000e669f5f83616639d3442b03108233e0054afbef8"
        ],
        "data": "0x",
        "logIndex": 202,
        "blockHash": "0x01b42f7463dcf332d042df2d633d21258557477ab2a2dccc70f4876d59f2f012"
      }
    ],
    "blockNumber": 8370660,
    "cumulativeGasUsed": "7438749",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xf09c27934A92c56c7C0dD6cBAc858C35fBd5170f",
    "0xE669f5f83616639D3442b03108233E0054afbef8"
  ],
  "solcInputHash": "9dd7be47a0ead41cf23f6aa7653a5c36",
  "metadata": "{\"compiler\":{\"version\":\"0.8.10+commit.fc410830\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"contract Authority\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomFeePercent\",\"type\":\"uint256\"}],\"name\":\"CustomFeePercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomHarvestDelay\",\"type\":\"uint256\"}],\"name\":\"CustomHarvestDelayUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomHarvestWindow\",\"type\":\"uint256\"}],\"name\":\"CustomHarvestWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCustomTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"CustomTargetFloatPercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDefaultFeePercent\",\"type\":\"uint256\"}],\"name\":\"DefaultFeePercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newDefaultHarvestDelay\",\"type\":\"uint64\"}],\"name\":\"DefaultHarvestDelayUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newDefaultHarvestWindow\",\"type\":\"uint128\"}],\"name\":\"DefaultHarvestWindowUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDefaultTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"DefaultTargetFloatPercentUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultHarvestDelay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultHarvestWindow\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultTargetFloatPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getVaultCustomFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getVaultCustomHarvestDelay\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getVaultCustomHarvestWindow\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getVaultCustomTargetFloatPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultFeePercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newDefaultHarvestDelay\",\"type\":\"uint64\"}],\"name\":\"setDefaultHarvestDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newDefaultHarvestWindow\",\"type\":\"uint128\"}],\"name\":\"setDefaultHarvestWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDefaultTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"setDefaultTargetFloatPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"customFeePercent\",\"type\":\"uint256\"}],\"name\":\"setVaultCustomFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"customHarvestDelay\",\"type\":\"uint64\"}],\"name\":\"setVaultCustomHarvestDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"customHarvestWindow\",\"type\":\"uint128\"}],\"name\":\"setVaultCustomHarvestWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"customTargetFloatPercent\",\"type\":\"uint256\"}],\"name\":\"setVaultCustomTargetFloatPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"syncFeePercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"syncHarvestDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"syncHarvestWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Vault\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"syncTargetFloatPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Transmissions11 and JetJadeja\",\"events\":{\"CustomFeePercentUpdated(address,uint256)\":{\"params\":{\"newCustomFeePercent\":\"The new custom fee percentage for the Vault.\",\"vault\":\"The Vault that had its custom fee percentage set/updated.\"}},\"CustomHarvestDelayUpdated(address,uint256)\":{\"params\":{\"newCustomHarvestDelay\":\"The new custom harvest delay for the Vault.\",\"vault\":\"The Vault that had its custom harvest delay set/updated.\"}},\"CustomHarvestWindowUpdated(address,uint256)\":{\"params\":{\"newCustomHarvestWindow\":\"The new custom harvest window for the Vault.\",\"vault\":\"The Vault that had its custom harvest window set/updated.\"}},\"CustomTargetFloatPercentUpdated(address,uint256)\":{\"params\":{\"newCustomTargetFloatPercent\":\"The new custom target float percentage for the Vault.\",\"vault\":\"The Vault that had its custom target float percentage set/updated.\"}},\"DefaultFeePercentUpdated(uint256)\":{\"params\":{\"newDefaultFeePercent\":\"The new default fee percentage.\"}},\"DefaultHarvestDelayUpdated(uint64)\":{\"params\":{\"newDefaultHarvestDelay\":\"The new default harvest delay.\"}},\"DefaultHarvestWindowUpdated(uint128)\":{\"params\":{\"newDefaultHarvestWindow\":\"The new default harvest window.\"}},\"DefaultTargetFloatPercentUpdated(uint256)\":{\"params\":{\"newDefaultTargetFloatPercent\":\"The new default target float percentage.\"}}},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_authority\":\"The Authority of the module.\",\"_owner\":\"The owner of the module.\"}},\"setDefaultFeePercent(uint256)\":{\"params\":{\"newDefaultFeePercent\":\"The new default fee percentage to set.\"}},\"setDefaultHarvestDelay(uint64)\":{\"params\":{\"newDefaultHarvestDelay\":\"The new default harvest delay to set.\"}},\"setDefaultHarvestWindow(uint128)\":{\"params\":{\"newDefaultHarvestWindow\":\"The new default harvest window to set.\"}},\"setDefaultTargetFloatPercent(uint256)\":{\"params\":{\"newDefaultTargetFloatPercent\":\"The new default target float percentage to set.\"}},\"setVaultCustomFeePercent(address,uint256)\":{\"params\":{\"customFeePercent\":\"The new custom fee percentage to set.\",\"vault\":\"The Vault to set the custom fee percentage for.\"}},\"setVaultCustomHarvestDelay(address,uint64)\":{\"params\":{\"customHarvestDelay\":\"The new custom harvest delay to set.\",\"vault\":\"The Vault to set the custom harvest delay for.\"}},\"setVaultCustomHarvestWindow(address,uint128)\":{\"params\":{\"customHarvestWindow\":\"The new custom harvest window to set.\",\"vault\":\"The Vault to set the custom harvest window for.\"}},\"setVaultCustomTargetFloatPercent(address,uint256)\":{\"params\":{\"customTargetFloatPercent\":\"The new custom target float percentage to set.\",\"vault\":\"The Vault to set the custom target float percentage for.\"}},\"syncFeePercent(address)\":{\"params\":{\"vault\":\"The Vault to sync the fee percentage for.\"}},\"syncHarvestDelay(address)\":{\"params\":{\"vault\":\"The Vault to sync the harvest delay for.\"}},\"syncHarvestWindow(address)\":{\"params\":{\"vault\":\"The Vault to sync the harvest window for.\"}},\"syncTargetFloatPercent(address)\":{\"params\":{\"vault\":\"The Vault to sync the target float percentage for.\"}}},\"stateVariables\":{\"getVaultCustomFeePercent\":{\"details\":\"Will be 0 if there is no custom fee percentage for the Vault.\"},\"getVaultCustomHarvestDelay\":{\"details\":\"Will be 0 if there is no custom harvest delay for the Vault.\"},\"getVaultCustomHarvestWindow\":{\"details\":\"Will be 0 if there is no custom harvest window for the Vault.\"},\"getVaultCustomTargetFloatPercent\":{\"details\":\"Will be 0 if there is no custom target float percentage for the Vault.\"}},\"title\":\"Rari Vault Configuration Module\",\"version\":1},\"userdoc\":{\"events\":{\"CustomFeePercentUpdated(address,uint256)\":{\"notice\":\"Emitted when a Vault has its custom fee percentage set/updated.\"},\"CustomHarvestDelayUpdated(address,uint256)\":{\"notice\":\"Emitted when a Vault has its custom harvest delay set/updated.\"},\"CustomHarvestWindowUpdated(address,uint256)\":{\"notice\":\"Emitted when a Vault has its custom harvest window set/updated.\"},\"CustomTargetFloatPercentUpdated(address,uint256)\":{\"notice\":\"Emitted when a Vault has its custom target float percentage set/updated.\"},\"DefaultFeePercentUpdated(uint256)\":{\"notice\":\"Emitted when the default fee percentage is updated.\"},\"DefaultHarvestDelayUpdated(uint64)\":{\"notice\":\"Emitted when the default harvest delay is updated.\"},\"DefaultHarvestWindowUpdated(uint128)\":{\"notice\":\"Emitted when the default harvest window is updated.\"},\"DefaultTargetFloatPercentUpdated(uint256)\":{\"notice\":\"Emitted when the default target float percentage is updated.\"}},\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Creates a Vault configuration module.\"},\"defaultFeePercent()\":{\"notice\":\"The default fee percentage for Vaults.\"},\"defaultHarvestDelay()\":{\"notice\":\"The default harvest delay for Vaults.\"},\"defaultHarvestWindow()\":{\"notice\":\"The default harvest window for Vaults.\"},\"defaultTargetFloatPercent()\":{\"notice\":\"The default target float percentage for Vaults.\"},\"getVaultCustomFeePercent(address)\":{\"notice\":\"Maps Vaults to their custom fee percentage.\"},\"getVaultCustomHarvestDelay(address)\":{\"notice\":\"Maps Vaults to their custom harvest delay.\"},\"getVaultCustomHarvestWindow(address)\":{\"notice\":\"Maps Vaults to their custom harvest window.\"},\"getVaultCustomTargetFloatPercent(address)\":{\"notice\":\"Maps Vaults to their custom target float percentage.\"},\"setDefaultFeePercent(uint256)\":{\"notice\":\"Sets the default fee percentage for Vaults.\"},\"setDefaultHarvestDelay(uint64)\":{\"notice\":\"Sets the default harvest delay for Vaults.\"},\"setDefaultHarvestWindow(uint128)\":{\"notice\":\"Sets the default harvest window for Vaults.\"},\"setDefaultTargetFloatPercent(uint256)\":{\"notice\":\"Sets the default target float percentage for Vaults.\"},\"setVaultCustomFeePercent(address,uint256)\":{\"notice\":\"Sets the custom fee percentage for the Vault.\"},\"setVaultCustomHarvestDelay(address,uint64)\":{\"notice\":\"Sets the custom harvest delay for the Vault.\"},\"setVaultCustomHarvestWindow(address,uint128)\":{\"notice\":\"Sets the custom harvest window for the Vault.\"},\"setVaultCustomTargetFloatPercent(address,uint256)\":{\"notice\":\"Sets the custom target float percentage for the Vault.\"},\"syncFeePercent(address)\":{\"notice\":\"Syncs a Vault's fee percentage with either the Vault's custom fee percentage or the default fee percentage if a custom percentage is not set.\"},\"syncHarvestDelay(address)\":{\"notice\":\"Syncs a Vault's harvest delay with either the Vault's custom harvest delay or the default harvest delay if a custom delay is not set.\"},\"syncHarvestWindow(address)\":{\"notice\":\"Syncs a Vault's harvest window with either the Vault's custom harvest window or the default harvest window if a custom window is not set.\"},\"syncTargetFloatPercent(address)\":{\"notice\":\"Syncs a Vault's target float percentage with either the Vault's custom target float percentage or the default target float percentage if a custom percentage is not set.\"}},\"notice\":\"Module for configuring Vault parameters.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/vault/modules/VaultConfigurationModule.sol\":\"VaultConfigurationModule\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"solmate/src/auth/Auth.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.0;\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed owner);\\n\\n    event AuthorityUpdated(Authority indexed authority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(_owner);\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(owner);\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual requiresAuth {\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(authority);\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority cachedAuthority = authority;\\n\\n        if (address(cachedAuthority) != address(0)) {\\n            try cachedAuthority.canCall(user, address(this), functionSig) returns (bool canCall) {\\n                if (canCall) return true;\\n            } catch {}\\n        }\\n\\n        return user == owner;\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x0b7f3c8e86c2b09d3498733bda5247da69956c971224f4e2a2a4e15d75eed707\",\"license\":\"AGPL-3.0\"},\"solmate/src/tokens/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] -= amount;\\n        }\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_PERMIT_SIGNATURE\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(bytes(\\\"1\\\")),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\",\"keccak256\":\"0x058e0708ffdd2b04a17b96b5775d9fab8daa19d3cd37d26ce6c923679bf9cc9a\",\"license\":\"AGPL-3.0\"},\"solmate/src/tokens/WETH.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"./ERC20.sol\\\";\\n\\nimport {SafeTransferLib} from \\\"../utils/SafeTransferLib.sol\\\";\\n\\n/// @notice Minimalist and modern Wrapped Ether implementation.\\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\\ncontract WETH is ERC20(\\\"Wrapped Ether\\\", \\\"WETH\\\", 18) {\\n    using SafeTransferLib for address;\\n\\n    event Deposit(address indexed from, uint256 amount);\\n\\n    event Withdrawal(address indexed to, uint256 amount);\\n\\n    function deposit() public payable {\\n        _mint(msg.sender, msg.value);\\n\\n        emit Deposit(msg.sender, msg.value);\\n    }\\n\\n    function withdraw(uint256 amount) external {\\n        _burn(msg.sender, amount);\\n\\n        msg.sender.safeTransferETH(amount);\\n\\n        emit Withdrawal(msg.sender, amount);\\n    }\\n\\n    receive() external payable {\\n        deposit();\\n    }\\n}\\n\",\"keccak256\":\"0x2d4eb620bad85b3bf6d5e8e4f4c53eb672c62ca4c9e053d3879d26a9d9996989\",\"license\":\"AGPL-3.0\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Modified from Dappsys V2 (https://github.com/dapp-org/dappsys-v2/blob/main/src/math.sol)\\n/// and ABDK (https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol)\\nlibrary FixedPointMathLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            COMMON BASE UNITS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant YAD = 1e8;\\n    uint256 internal constant WAD = 1e18;\\n    uint256 internal constant RAY = 1e27;\\n    uint256 internal constant RAD = 1e45;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function fmul(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(x == 0 || (x * y) / x == y)\\n            if iszero(or(iszero(x), eq(div(z, x), y))) {\\n                revert(0, 0)\\n            }\\n\\n            // If baseUnit is zero this will return zero instead of reverting.\\n            z := div(z, baseUnit)\\n        }\\n    }\\n\\n    function fdiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * baseUnit in z for now.\\n            z := mul(x, baseUnit)\\n\\n            if or(\\n                // Revert if y is zero to ensure we don't divide by zero below.\\n                iszero(y),\\n                // Equivalent to require(x == 0 || (x * baseUnit) / x == baseUnit)\\n                iszero(or(iszero(x), eq(div(z, x), baseUnit)))\\n            ) {\\n                revert(0, 0)\\n            }\\n\\n            // We ensure y is not zero above, so there is never division by zero here.\\n            z := div(z, y)\\n        }\\n    }\\n\\n    function fpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 baseUnit\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    z := baseUnit\\n                }\\n                default {\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    z := baseUnit\\n                }\\n                default {\\n                    z := x\\n                }\\n                let half := div(baseUnit, 2)\\n                for {\\n                    n := div(n, 2)\\n                } n {\\n                    n := div(n, 2)\\n                } {\\n                    let xx := mul(x, x)\\n                    if iszero(eq(div(xx, x), x)) {\\n                        revert(0, 0)\\n                    }\\n                    let xxRound := add(xx, half)\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n                    x := div(xxRound, baseUnit)\\n                    if mod(n, 2) {\\n                        let zx := mul(z, x)\\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\\n                            revert(0, 0)\\n                        }\\n                        let zxRound := add(zx, half)\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n                        z := div(zxRound, baseUnit)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\\n        if (x == 0) return 0;\\n\\n        result = 1;\\n\\n        uint256 xAux = x;\\n\\n        if (xAux >= 0x100000000000000000000000000000000) {\\n            xAux >>= 128;\\n            result <<= 64;\\n        }\\n\\n        if (xAux >= 0x10000000000000000) {\\n            xAux >>= 64;\\n            result <<= 32;\\n        }\\n\\n        if (xAux >= 0x100000000) {\\n            xAux >>= 32;\\n            result <<= 16;\\n        }\\n\\n        if (xAux >= 0x10000) {\\n            xAux >>= 16;\\n            result <<= 8;\\n        }\\n\\n        if (xAux >= 0x100) {\\n            xAux >>= 8;\\n            result <<= 4;\\n        }\\n\\n        if (xAux >= 0x10) {\\n            xAux >>= 4;\\n            result <<= 2;\\n        }\\n\\n        if (xAux >= 0x8) result <<= 1;\\n\\n        unchecked {\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n            result = (result + x / result) >> 1;\\n\\n            uint256 roundedDownResult = x / result;\\n\\n            if (result > roundedDownResult) result = roundedDownResult;\\n        }\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x > y ? x : y;\\n    }\\n}\\n\",\"keccak256\":\"0x11bae04ee197bfb3b5dbb4a95eae81f500314b76be91ad692b10f00782fc9bf6\",\"license\":\"AGPL-3.0\"},\"solmate/src/utils/SafeCastLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.0;\\n\\n/// @notice Safe unsigned integer casting library that reverts on overflow.\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeCast.sol)\\nlibrary SafeCastLib {\\n    function safeCastTo248(uint256 x) internal pure returns (uint248 y) {\\n        require(x <= type(uint248).max);\\n\\n        y = uint248(x);\\n    }\\n\\n    function safeCastTo128(uint256 x) internal pure returns (uint128 y) {\\n        require(x <= type(uint128).max);\\n\\n        y = uint128(x);\\n    }\\n\\n    function safeCastTo96(uint256 x) internal pure returns (uint96 y) {\\n        require(x <= type(uint96).max);\\n\\n        y = uint96(x);\\n    }\\n\\n    function safeCastTo64(uint256 x) internal pure returns (uint64 y) {\\n        require(x <= type(uint64).max);\\n\\n        y = uint64(x);\\n    }\\n\\n    function safeCastTo32(uint256 x) internal pure returns (uint32 y) {\\n        require(x <= type(uint32).max);\\n\\n        y = uint32(x);\\n    }\\n}\\n\",\"keccak256\":\"0x58d6e9ae42c781636b8a953a009d95da627b8d1def3905245d1ccc7ffd954a1e\",\"license\":\"AGPL-3.0\"},\"solmate/src/utils/SafeTransferLib.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x50f187c86835070ec519acffcc259cd7900fdb85cb53333210fba9491eb65eca\",\"license\":\"AGPL-3.0\"},\"src/vault/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\nimport { Auth } from \\\"solmate/src/auth/Auth.sol\\\";\\nimport { WETH } from \\\"solmate/src/tokens/WETH.sol\\\";\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\nimport { SafeCastLib } from \\\"solmate/src/utils/SafeCastLib.sol\\\";\\nimport { SafeTransferLib } from \\\"solmate/src/utils/SafeTransferLib.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\nimport { Strategy, ERC20Strategy, ETHStrategy } from \\\"./interfaces/Strategy.sol\\\";\\n\\n/// @title Rari Vault (rvToken)\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Flexible, minimalist, and gas-optimized yield\\n/// aggregator for earning interest on any ERC20 token.\\ncontract Vault is ERC20, Auth {\\n\\tusing SafeCastLib for uint256;\\n\\tusing SafeTransferLib for ERC20;\\n\\tusing FixedPointMathLib for uint256;\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                                IMMUTABLES\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice The underlying token the Vault accepts.\\n\\tERC20 public immutable UNDERLYING;\\n\\n\\t/// @notice The base unit of the underlying token and hence rvToken.\\n\\t/// @dev Equal to 10 ** decimals. Used for fixed point arithmetic.\\n\\tuint256 public immutable BASE_UNIT;\\n\\n\\t/// @notice Creates a new Vault that accepts a specific underlying token.\\n\\t/// @param _UNDERLYING The ERC20 compliant token the Vault should accept.\\n\\tconstructor(ERC20 _UNDERLYING)\\n\\t\\tERC20(\\n\\t\\t\\t// ex: Parasite Dai Stablecoin Vault\\n\\t\\t\\tstring(abi.encodePacked(\\\"Parasite \\\", _UNDERLYING.name(), \\\" Vault\\\")),\\n\\t\\t\\t// ex: pDAI\\n\\t\\t\\tstring(abi.encodePacked(\\\"p\\\", _UNDERLYING.symbol())),\\n\\t\\t\\t// ex: 18\\n\\t\\t\\t_UNDERLYING.decimals()\\n\\t\\t)\\n\\t\\tAuth(Auth(msg.sender).owner(), Auth(msg.sender).authority())\\n\\t{\\n\\t\\tUNDERLYING = _UNDERLYING;\\n\\n\\t\\tBASE_UNIT = 10**decimals;\\n\\n\\t\\t// Prevent minting of rvTokens until\\n\\t\\t// the initialize function is called.\\n\\t\\ttotalSupply = type(uint256).max;\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                           FEE CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice The percentage of profit recognized each harvest to reserve as fees.\\n\\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n\\tuint256 public feePercent;\\n\\n\\t/// @notice Emitted when the fee percentage is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newFeePercent The new fee percentage.\\n\\tevent FeePercentUpdated(address indexed user, uint256 newFeePercent);\\n\\n\\t/// @notice Sets a new fee percentage.\\n\\t/// @param newFeePercent The new fee percentage.\\n\\tfunction setFeePercent(uint256 newFeePercent) external requiresAuth {\\n\\t\\t// A fee percentage over 100% doesn't make sense.\\n\\t\\trequire(newFeePercent <= 1e18, \\\"FEE_TOO_HIGH\\\");\\n\\n\\t\\t// Update the fee percentage.\\n\\t\\tfeePercent = newFeePercent;\\n\\n\\t\\temit FeePercentUpdated(msg.sender, newFeePercent);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                        HARVEST CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when the harvest window is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newHarvestWindow The new harvest window.\\n\\tevent HarvestWindowUpdated(address indexed user, uint128 newHarvestWindow);\\n\\n\\t/// @notice Emitted when the harvest delay is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newHarvestDelay The new harvest delay.\\n\\tevent HarvestDelayUpdated(address indexed user, uint64 newHarvestDelay);\\n\\n\\t/// @notice Emitted when the harvest delay is scheduled to be updated next harvest.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newHarvestDelay The scheduled updated harvest delay.\\n\\tevent HarvestDelayUpdateScheduled(address indexed user, uint64 newHarvestDelay);\\n\\n\\t/// @notice The period in seconds during which multiple harvests can occur\\n\\t/// regardless if they are taking place before the harvest delay has elapsed.\\n\\t/// @dev Long harvest windows open the Vault up to profit distribution slowdown attacks.\\n\\tuint128 public harvestWindow;\\n\\n\\t/// @notice The period in seconds over which locked profit is unlocked.\\n\\t/// @dev Cannot be 0 as it opens harvests up to sandwich attacks.\\n\\tuint64 public harvestDelay;\\n\\n\\t/// @notice The value that will replace harvestDelay next harvest.\\n\\t/// @dev In the case that the next delay is 0, no update will be applied.\\n\\tuint64 public nextHarvestDelay;\\n\\n\\t/// @notice Sets a new harvest window.\\n\\t/// @param newHarvestWindow The new harvest window.\\n\\t/// @dev The Vault's harvestDelay must already be set before calling.\\n\\tfunction setHarvestWindow(uint128 newHarvestWindow) external requiresAuth {\\n\\t\\t// A harvest window longer than the harvest delay doesn't make sense.\\n\\t\\trequire(newHarvestWindow <= harvestDelay, \\\"WINDOW_TOO_LONG\\\");\\n\\n\\t\\t// Update the harvest window.\\n\\t\\tharvestWindow = newHarvestWindow;\\n\\n\\t\\temit HarvestWindowUpdated(msg.sender, newHarvestWindow);\\n\\t}\\n\\n\\t/// @notice Sets a new harvest delay.\\n\\t/// @param newHarvestDelay The new harvest delay to set.\\n\\t/// @dev If the current harvest delay is 0, meaning it has not\\n\\t/// been set before, it will be updated immediately, otherwise\\n\\t/// it will be scheduled to take effect after the next harvest.\\n\\tfunction setHarvestDelay(uint64 newHarvestDelay) external requiresAuth {\\n\\t\\t// A harvest delay of 0 makes harvests vulnerable to sandwich attacks.\\n\\t\\trequire(newHarvestDelay != 0, \\\"DELAY_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// A harvest delay longer than 1 year doesn't make sense.\\n\\t\\trequire(newHarvestDelay <= 365 days, \\\"DELAY_TOO_LONG\\\");\\n\\n\\t\\t// If the harvest delay is 0, meaning it has not been set before:\\n\\t\\tif (harvestDelay == 0) {\\n\\t\\t\\t// We'll apply the update immediately.\\n\\t\\t\\tharvestDelay = newHarvestDelay;\\n\\n\\t\\t\\temit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n\\t\\t} else {\\n\\t\\t\\t// We'll apply the update next harvest.\\n\\t\\t\\tnextHarvestDelay = newHarvestDelay;\\n\\n\\t\\t\\temit HarvestDelayUpdateScheduled(msg.sender, newHarvestDelay);\\n\\t\\t}\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                       TARGET FLOAT CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice The desired percentage of the Vault's holdings to keep as float.\\n\\t/// @dev A fixed point number where 1e18 represents 100% and 0 represents 0%.\\n\\tuint256 public targetFloatPercent;\\n\\n\\t/// @notice Emitted when the target float percentage is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newTargetFloatPercent The new target float percentage.\\n\\tevent TargetFloatPercentUpdated(address indexed user, uint256 newTargetFloatPercent);\\n\\n\\t/// @notice Set a new target float percentage.\\n\\t/// @param newTargetFloatPercent The new target float percentage.\\n\\tfunction setTargetFloatPercent(uint256 newTargetFloatPercent) external requiresAuth {\\n\\t\\t// A target float percentage over 100% doesn't make sense.\\n\\t\\trequire(targetFloatPercent <= 1e18, \\\"TARGET_TOO_HIGH\\\");\\n\\n\\t\\t// Update the target float percentage.\\n\\t\\ttargetFloatPercent = newTargetFloatPercent;\\n\\n\\t\\temit TargetFloatPercentUpdated(msg.sender, newTargetFloatPercent);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                   UNDERLYING IS WETH CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Whether the Vault should treat the underlying token as WETH compatible.\\n\\t/// @dev If enabled the Vault will allow trusting strategies that accept Ether.\\n\\tbool public underlyingIsWETH;\\n\\n\\t/// @notice Emitted when whether the Vault should treat the underlying as WETH is updated.\\n\\t/// @param user The authorized user who triggered the update.\\n\\t/// @param newUnderlyingIsWETH Whether the Vault nows treats the underlying as WETH.\\n\\tevent UnderlyingIsWETHUpdated(address indexed user, bool newUnderlyingIsWETH);\\n\\n\\t/// @notice Sets whether the Vault treats the underlying as WETH.\\n\\t/// @param newUnderlyingIsWETH Whether the Vault should treat the underlying as WETH.\\n\\t/// @dev The underlying token must have 18 decimals, to match Ether's decimal scheme.\\n\\tfunction setUnderlyingIsWETH(bool newUnderlyingIsWETH) external requiresAuth {\\n\\t\\t// Ensure the underlying token's decimals match ETH.\\n\\t\\trequire(UNDERLYING.decimals() == 18, \\\"WRONG_DECIMALS\\\");\\n\\n\\t\\t// Update whether the Vault treats the underlying as WETH.\\n\\t\\tunderlyingIsWETH = newUnderlyingIsWETH;\\n\\n\\t\\temit UnderlyingIsWETHUpdated(msg.sender, newUnderlyingIsWETH);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                          STRATEGY STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice The total amount of underlying tokens held in strategies at the time of the last harvest.\\n\\t/// @dev Includes maxLockedProfit, must be correctly subtracted to compute available/free holdings.\\n\\tuint256 public totalStrategyHoldings;\\n\\n\\t/// @dev Packed struct of strategy data.\\n\\t/// @param trusted Whether the strategy is trusted.\\n\\t/// @param balance The amount of underlying tokens held in the strategy.\\n\\tstruct StrategyData {\\n\\t\\t// Used to determine if the Vault will operate on a strategy.\\n\\t\\tbool trusted;\\n\\t\\t// Used to determine profit and loss during harvests of the strategy.\\n\\t\\tuint248 balance;\\n\\t}\\n\\n\\t/// @notice Maps strategies to data the Vault holds on them.\\n\\tmapping(Strategy => StrategyData) public getStrategyData;\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                             HARVEST STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice A timestamp representing when the first harvest in the most recent harvest window occurred.\\n\\t/// @dev May be equal to lastHarvest if there was/has only been one harvest in the most last/current window.\\n\\tuint64 public lastHarvestWindowStart;\\n\\n\\t/// @notice A timestamp representing when the most recent harvest occurred.\\n\\tuint64 public lastHarvest;\\n\\n\\t/// @notice The amount of locked profit at the end of the last harvest.\\n\\tuint128 public maxLockedProfit;\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                        WITHDRAWAL QUEUE STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice An ordered array of strategies representing the withdrawal queue.\\n\\t/// @dev The queue is processed in descending order, meaning the last index will be withdrawn from first.\\n\\t/// @dev Strategies that are untrusted, duplicated, or have no balance are filtered out when encountered at\\n\\t/// withdrawal time, not validated upfront, meaning the queue may not reflect the \\\"true\\\" set used for withdrawals.\\n\\tStrategy[] public withdrawalQueue;\\n\\n\\t/// @notice Gets the full withdrawal queue.\\n\\t/// @return An ordered array of strategies representing the withdrawal queue.\\n\\t/// @dev This is provided because Solidity converts public arrays into index getters,\\n\\t/// but we need a way to allow external contracts and users to access the whole array.\\n\\tfunction getWithdrawalQueue() external view returns (Strategy[] memory) {\\n\\t\\treturn withdrawalQueue;\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                        DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after a successful deposit.\\n\\t/// @param user The address that deposited into the Vault.\\n\\t/// @param underlyingAmount The amount of underlying tokens that were deposited.\\n\\tevent Deposit(address indexed user, uint256 underlyingAmount);\\n\\n\\t/// @notice Emitted after a successful withdrawal.\\n\\t/// @param user The address that withdrew from the Vault.\\n\\t/// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n\\tevent Withdraw(address indexed user, uint256 underlyingAmount);\\n\\n\\t/// @notice Deposit a specific amount of underlying tokens.\\n\\t/// @param underlyingAmount The amount of the underlying token to deposit.\\n\\tfunction deposit(uint256 underlyingAmount) external {\\n\\t\\t// We don't allow depositing 0 to prevent emitting a useless event.\\n\\t\\trequire(underlyingAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Determine the equivalent amount of rvTokens and mint them.\\n\\t\\t_mint(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n\\t\\temit Deposit(msg.sender, underlyingAmount);\\n\\n\\t\\t// Transfer in underlying tokens from the user.\\n\\t\\t// This will revert if the user does not have the amount specified.\\n\\t\\tUNDERLYING.safeTransferFrom(msg.sender, address(this), underlyingAmount);\\n\\t}\\n\\n\\t/// @notice Withdraw a specific amount of underlying tokens.\\n\\t/// @param underlyingAmount The amount of underlying tokens to withdraw.\\n\\tfunction withdraw(uint256 underlyingAmount) external {\\n\\t\\t// We don't allow withdrawing 0 to prevent emitting a useless event.\\n\\t\\trequire(underlyingAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Determine the equivalent amount of rvTokens and burn them.\\n\\t\\t// This will revert if the user does not have enough rvTokens.\\n\\t\\t_burn(msg.sender, underlyingAmount.fdiv(exchangeRate(), BASE_UNIT));\\n\\n\\t\\temit Withdraw(msg.sender, underlyingAmount);\\n\\n\\t\\t// Withdraw from strategies if needed and transfer.\\n\\t\\ttransferUnderlyingTo(msg.sender, underlyingAmount);\\n\\t}\\n\\n\\t/// @notice Redeem a specific amount of rvTokens for underlying tokens.\\n\\t/// @param rvTokenAmount The amount of rvTokens to redeem for underlying tokens.\\n\\tfunction redeem(uint256 rvTokenAmount) external {\\n\\t\\t// We don't allow redeeming 0 to prevent emitting a useless event.\\n\\t\\trequire(rvTokenAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Determine the equivalent amount of underlying tokens.\\n\\t\\tuint256 underlyingAmount = rvTokenAmount.fmul(exchangeRate(), BASE_UNIT);\\n\\n\\t\\t// Burn the provided amount of rvTokens.\\n\\t\\t// This will revert if the user does not have enough rvTokens.\\n\\t\\t_burn(msg.sender, rvTokenAmount);\\n\\n\\t\\temit Withdraw(msg.sender, underlyingAmount);\\n\\t\\t// Withdraw from strategies if needed and transfer.\\n\\t\\ttransferUnderlyingTo(msg.sender, underlyingAmount);\\n\\t}\\n\\n\\t/// @dev Transfers a specific amount of underlying tokens held in strategies and/or float to a recipient.\\n\\t/// @dev Only withdraws from strategies if needed and maintains the target float percentage if possible.\\n\\t/// @param recipient The user to transfer the underlying tokens to.\\n\\t/// @param underlyingAmount The amount of underlying tokens to transfer.\\n\\tfunction transferUnderlyingTo(address recipient, uint256 underlyingAmount) internal {\\n\\t\\t// Get the Vault's floating balance.\\n\\t\\tuint256 float = totalFloat();\\n\\n\\t\\t// If the amount is greater than the float, withdraw from strategies.\\n\\t\\tif (underlyingAmount > float) {\\n\\t\\t\\t// Compute the amount needed to reach our target float percentage.\\n\\t\\t\\tuint256 floatMissingForTarget = (totalHoldings() - underlyingAmount).fmul(\\n\\t\\t\\t\\ttargetFloatPercent,\\n\\t\\t\\t\\t1e18\\n\\t\\t\\t);\\n\\n\\t\\t\\t// Compute the bare minimum amount we need for this withdrawal.\\n\\t\\t\\tuint256 floatMissingForWithdrawal = underlyingAmount - float;\\n\\n\\t\\t\\t// Pull enough to cover the withdrawal and reach our target float percentage.\\n\\t\\t\\tpullFromWithdrawalQueue(floatMissingForWithdrawal + floatMissingForTarget);\\n\\t\\t}\\n\\n\\t\\t// Transfer the provided amount of underlying tokens.\\n\\t\\tUNDERLYING.safeTransfer(recipient, underlyingAmount);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                        VAULT ACCOUNTING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Returns a user's Vault balance in underlying tokens.\\n\\t/// @param user The user to get the underlying balance of.\\n\\t/// @return The user's Vault balance in underlying tokens.\\n\\tfunction balanceOfUnderlying(address user) external view returns (uint256) {\\n\\t\\treturn balanceOf[user].fmul(exchangeRate(), BASE_UNIT);\\n\\t}\\n\\n\\t/// @notice Returns the amount of underlying tokens an rvToken can be redeemed for.\\n\\t/// @return The amount of underlying tokens an rvToken can be redeemed for.\\n\\tfunction exchangeRate() public view returns (uint256) {\\n\\t\\t// Get the total supply of rvTokens.\\n\\t\\tuint256 rvTokenSupply = totalSupply;\\n\\n\\t\\t// If there are no rvTokens in circulation, return an exchange rate of 1:1.\\n\\t\\tif (rvTokenSupply == 0) return BASE_UNIT;\\n\\n\\t\\t// Calculate the exchange rate by dividing the total holdings by the rvToken supply.\\n\\t\\treturn totalHoldings().fdiv(rvTokenSupply, BASE_UNIT);\\n\\t}\\n\\n\\t/// @notice Calculates the total amount of underlying tokens the Vault holds.\\n\\t/// @return totalUnderlyingHeld The total amount of underlying tokens the Vault holds.\\n\\tfunction totalHoldings() public view returns (uint256 totalUnderlyingHeld) {\\n\\t\\tunchecked {\\n\\t\\t\\t// Cannot underflow as locked profit can't exceed total strategy holdings.\\n\\t\\t\\ttotalUnderlyingHeld = totalStrategyHoldings - lockedProfit();\\n\\t\\t}\\n\\n\\t\\t// Include our floating balance in the total.\\n\\t\\ttotalUnderlyingHeld += totalFloat();\\n\\t}\\n\\n\\t/// @notice Calculates the current amount of locked profit.\\n\\t/// @return The current amount of locked profit.\\n\\tfunction lockedProfit() public view returns (uint256) {\\n\\t\\t// Get the last harvest and harvest delay.\\n\\t\\tuint256 previousHarvest = lastHarvest;\\n\\t\\tuint256 harvestInterval = harvestDelay;\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// If the harvest delay has passed, there is no locked profit.\\n\\t\\t\\t// Cannot overflow on human timescales since harvestInterval is capped.\\n\\t\\t\\tif (block.timestamp >= previousHarvest + harvestInterval) return 0;\\n\\n\\t\\t\\t// Get the maximum amount we could return.\\n\\t\\t\\tuint256 maximumLockedProfit = maxLockedProfit;\\n\\n\\t\\t\\t// Compute how much profit remains locked based on the last harvest and harvest delay.\\n\\t\\t\\t// It's impossible for the previous harvest to be in the future, so this will never underflow.\\n\\t\\t\\treturn\\n\\t\\t\\t\\tmaximumLockedProfit -\\n\\t\\t\\t\\t(maximumLockedProfit * (block.timestamp - previousHarvest)) /\\n\\t\\t\\t\\tharvestInterval;\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Returns the amount of underlying tokens that idly sit in the Vault.\\n\\t/// @return The amount of underlying tokens that sit idly in the Vault.\\n\\tfunction totalFloat() public view returns (uint256) {\\n\\t\\treturn UNDERLYING.balanceOf(address(this));\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                             HARVEST LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after a successful harvest.\\n\\t/// @param user The authorized user who triggered the harvest.\\n\\t/// @param strategies The trusted strategies that were harvested.\\n\\tevent Harvest(address indexed user, Strategy[] strategies);\\n\\n\\t/// @notice Harvest a set of trusted strategies.\\n\\t/// @param strategies The trusted strategies to harvest.\\n\\t/// @dev Will always revert if called outside of an active\\n\\t/// harvest window or before the harvest delay has passed.\\n\\tfunction harvest(Strategy[] calldata strategies) external requiresAuth {\\n\\t\\t// If this is the first harvest after the last window:\\n\\t\\tif (block.timestamp >= lastHarvest + harvestDelay) {\\n\\t\\t\\t// Set the harvest window's start timestamp.\\n\\t\\t\\t// Cannot overflow 64 bits on human timescales.\\n\\t\\t\\tlastHarvestWindowStart = uint64(block.timestamp);\\n\\t\\t} else {\\n\\t\\t\\t// We know this harvest is not the first in the window so we need to ensure it's within it.\\n\\t\\t\\trequire(block.timestamp <= lastHarvestWindowStart + harvestWindow, \\\"BAD_HARVEST_TIME\\\");\\n\\t\\t}\\n\\n\\t\\t// Get the Vault's current total strategy holdings.\\n\\t\\tuint256 oldTotalStrategyHoldings = totalStrategyHoldings;\\n\\n\\t\\t// Used to store the total profit accrued by the strategies.\\n\\t\\tuint256 totalProfitAccrued;\\n\\n\\t\\t// Used to store the new total strategy holdings after harvesting.\\n\\t\\tuint256 newTotalStrategyHoldings = oldTotalStrategyHoldings;\\n\\n\\t\\t// Will revert if any of the specified strategies are untrusted.\\n\\t\\tfor (uint256 i = 0; i < strategies.length; i++) {\\n\\t\\t\\t// Get the strategy at the current index.\\n\\t\\t\\tStrategy strategy = strategies[i];\\n\\n\\t\\t\\t// If an untrusted strategy could be harvested a malicious user could use\\n\\t\\t\\t// a fake strategy that over-reports holdings to manipulate the exchange rate.\\n\\t\\t\\trequire(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n\\t\\t\\t// Get the strategy's previous and current balance.\\n\\t\\t\\tuint256 balanceLastHarvest = getStrategyData[strategy].balance;\\n\\t\\t\\tuint256 balanceThisHarvest = strategy.balanceOfUnderlying(address(this));\\n\\n\\t\\t\\t// Update the strategy's stored balance. Cast overflow is unrealistic.\\n\\t\\t\\tgetStrategyData[strategy].balance = balanceThisHarvest.safeCastTo248();\\n\\n\\t\\t\\t// Increase/decrease newTotalStrategyHoldings based on the profit/loss registered.\\n\\t\\t\\t// We cannot wrap the subtraction in parenthesis as it would underflow if the strategy had a loss.\\n\\t\\t\\tnewTotalStrategyHoldings =\\n\\t\\t\\t\\tnewTotalStrategyHoldings +\\n\\t\\t\\t\\tbalanceThisHarvest -\\n\\t\\t\\t\\tbalanceLastHarvest;\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t// Update the total profit accrued while counting losses as zero profit.\\n\\t\\t\\t\\t// Cannot overflow as we already increased total holdings without reverting.\\n\\t\\t\\t\\ttotalProfitAccrued += balanceThisHarvest > balanceLastHarvest\\n\\t\\t\\t\\t\\t? balanceThisHarvest - balanceLastHarvest // Profits since last harvest.\\n\\t\\t\\t\\t\\t: 0; // If the strategy registered a net loss we don't have any new profit.\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// Compute fees as the fee percent multiplied by the profit.\\n\\t\\tuint256 feesAccrued = totalProfitAccrued.fmul(feePercent, 1e18);\\n\\n\\t\\t// If we accrued any fees, mint an equivalent amount of rvTokens.\\n\\t\\t// Authorized users can claim the newly minted rvTokens via claimFees.\\n\\t\\t_mint(address(this), feesAccrued.fdiv(exchangeRate(), BASE_UNIT));\\n\\n\\t\\t// Update max unlocked profit based on any remaining locked profit plus new profit.\\n\\t\\tmaxLockedProfit = (lockedProfit() + totalProfitAccrued - feesAccrued).safeCastTo128();\\n\\n\\t\\t// Set strategy holdings to our new total.\\n\\t\\ttotalStrategyHoldings = newTotalStrategyHoldings;\\n\\n\\t\\t// Update the last harvest timestamp.\\n\\t\\t// Cannot overflow on human timescales.\\n\\t\\tlastHarvest = uint64(block.timestamp);\\n\\n\\t\\temit Harvest(msg.sender, strategies);\\n\\n\\t\\t// Get the next harvest delay.\\n\\t\\tuint64 newHarvestDelay = nextHarvestDelay;\\n\\n\\t\\t// If the next harvest delay is not 0:\\n\\t\\tif (newHarvestDelay != 0) {\\n\\t\\t\\t// Update the harvest delay.\\n\\t\\t\\tharvestDelay = newHarvestDelay;\\n\\n\\t\\t\\t// Reset the next harvest delay.\\n\\t\\t\\tnextHarvestDelay = 0;\\n\\n\\t\\t\\temit HarvestDelayUpdated(msg.sender, newHarvestDelay);\\n\\t\\t}\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                    STRATEGY DEPOSIT/WITHDRAWAL LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after the Vault deposits into a strategy contract.\\n\\t/// @param user The authorized user who triggered the deposit.\\n\\t/// @param strategy The strategy that was deposited into.\\n\\t/// @param underlyingAmount The amount of underlying tokens that were deposited.\\n\\tevent StrategyDeposit(\\n\\t\\taddress indexed user,\\n\\t\\tStrategy indexed strategy,\\n\\t\\tuint256 underlyingAmount\\n\\t);\\n\\n\\t/// @notice Emitted after the Vault withdraws funds from a strategy contract.\\n\\t/// @param user The authorized user who triggered the withdrawal.\\n\\t/// @param strategy The strategy that was withdrawn from.\\n\\t/// @param underlyingAmount The amount of underlying tokens that were withdrawn.\\n\\tevent StrategyWithdrawal(\\n\\t\\taddress indexed user,\\n\\t\\tStrategy indexed strategy,\\n\\t\\tuint256 underlyingAmount\\n\\t);\\n\\n\\t/// @notice Deposit a specific amount of float into a trusted strategy.\\n\\t/// @param strategy The trusted strategy to deposit into.\\n\\t/// @param underlyingAmount The amount of underlying tokens in float to deposit.\\n\\tfunction depositIntoStrategy(Strategy strategy, uint256 underlyingAmount)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// A strategy must be trusted before it can be deposited into.\\n\\t\\trequire(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n\\t\\t// We don't allow depositing 0 to prevent emitting a useless event.\\n\\t\\trequire(underlyingAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Increase totalStrategyHoldings to account for the deposit.\\n\\t\\ttotalStrategyHoldings += underlyingAmount;\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// Without this the next harvest would count the deposit as profit.\\n\\t\\t\\t// Cannot overflow as the balance of one strategy can't exceed the sum of all.\\n\\t\\t\\tgetStrategyData[strategy].balance += underlyingAmount.safeCastTo248();\\n\\t\\t}\\n\\n\\t\\temit StrategyDeposit(msg.sender, strategy, underlyingAmount);\\n\\n\\t\\t// We need to deposit differently if the strategy takes ETH.\\n\\t\\tif (strategy.isCEther()) {\\n\\t\\t\\t// Unwrap the right amount of WETH.\\n\\t\\t\\tWETH(payable(address(UNDERLYING))).withdraw(underlyingAmount);\\n\\n\\t\\t\\t// Deposit into the strategy and assume it will revert on error.\\n\\t\\t\\tETHStrategy(address(strategy)).mint{ value: underlyingAmount }();\\n\\t\\t} else {\\n\\t\\t\\t// Approve underlyingAmount to the strategy so we can deposit.\\n\\t\\t\\tUNDERLYING.safeApprove(address(strategy), underlyingAmount);\\n\\n\\t\\t\\t// Deposit into the strategy and revert if it returns an error code.\\n\\t\\t\\trequire(ERC20Strategy(address(strategy)).mint(underlyingAmount) == 0, \\\"MINT_FAILED\\\");\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Withdraw a specific amount of underlying tokens from a strategy.\\n\\t/// @param strategy The strategy to withdraw from.\\n\\t/// @param underlyingAmount  The amount of underlying tokens to withdraw.\\n\\t/// @dev Withdrawing from a strategy will not remove it from the withdrawal queue.\\n\\tfunction withdrawFromStrategy(Strategy strategy, uint256 underlyingAmount)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// A strategy must be trusted before it can be withdrawn from.\\n\\t\\trequire(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n\\t\\t// We don't allow withdrawing 0 to prevent emitting a useless event.\\n\\t\\trequire(underlyingAmount != 0, \\\"AMOUNT_CANNOT_BE_ZERO\\\");\\n\\n\\t\\t// Without this the next harvest would count the withdrawal as a loss.\\n\\t\\tgetStrategyData[strategy].balance -= underlyingAmount.safeCastTo248();\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// Decrease totalStrategyHoldings to account for the withdrawal.\\n\\t\\t\\t// Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n\\t\\t\\ttotalStrategyHoldings -= underlyingAmount;\\n\\t\\t}\\n\\n\\t\\temit StrategyWithdrawal(msg.sender, strategy, underlyingAmount);\\n\\n\\t\\t// Withdraw from the strategy and revert if it returns an error code.\\n\\t\\trequire(strategy.redeemUnderlying(underlyingAmount) == 0, \\\"REDEEM_FAILED\\\");\\n\\n\\t\\t// Wrap the withdrawn Ether into WETH if necessary.\\n\\t\\tif (strategy.isCEther())\\n\\t\\t\\tWETH(payable(address(UNDERLYING))).deposit{ value: underlyingAmount }();\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                      STRATEGY TRUST/DISTRUST LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when a strategy is set to trusted.\\n\\t/// @param user The authorized user who trusted the strategy.\\n\\t/// @param strategy The strategy that became trusted.\\n\\tevent StrategyTrusted(address indexed user, Strategy indexed strategy);\\n\\n\\t/// @notice Emitted when a strategy is set to untrusted.\\n\\t/// @param user The authorized user who untrusted the strategy.\\n\\t/// @param strategy The strategy that became untrusted.\\n\\tevent StrategyDistrusted(address indexed user, Strategy indexed strategy);\\n\\n\\t/// @notice Stores a strategy as trusted, enabling it to be harvested.\\n\\t/// @param strategy The strategy to make trusted.\\n\\tfunction trustStrategy(Strategy strategy) external requiresAuth {\\n\\t\\t// Ensure the strategy accepts the correct underlying token.\\n\\t\\t// If the strategy accepts ETH the Vault should accept WETH, it'll handle wrapping when necessary.\\n\\t\\trequire(\\n\\t\\t\\tstrategy.isCEther()\\n\\t\\t\\t\\t? underlyingIsWETH\\n\\t\\t\\t\\t: ERC20Strategy(address(strategy)).underlying() == UNDERLYING,\\n\\t\\t\\t\\\"WRONG_UNDERLYING\\\"\\n\\t\\t);\\n\\n\\t\\t// Store the strategy as trusted.\\n\\t\\tgetStrategyData[strategy].trusted = true;\\n\\n\\t\\temit StrategyTrusted(msg.sender, strategy);\\n\\t}\\n\\n\\t/// @notice Stores a strategy as untrusted, disabling it from being harvested.\\n\\t/// @param strategy The strategy to make untrusted.\\n\\tfunction distrustStrategy(Strategy strategy) external requiresAuth {\\n\\t\\t// Store the strategy as untrusted.\\n\\t\\tgetStrategyData[strategy].trusted = false;\\n\\n\\t\\temit StrategyDistrusted(msg.sender, strategy);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                         WITHDRAWAL QUEUE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when a strategy is pushed to the withdrawal queue.\\n\\t/// @param user The authorized user who triggered the push.\\n\\t/// @param pushedStrategy The strategy pushed to the withdrawal queue.\\n\\tevent WithdrawalQueuePushed(address indexed user, Strategy indexed pushedStrategy);\\n\\n\\t/// @notice Emitted when a strategy is popped from the withdrawal queue.\\n\\t/// @param user The authorized user who triggered the pop.\\n\\t/// @param poppedStrategy The strategy popped from the withdrawal queue.\\n\\tevent WithdrawalQueuePopped(address indexed user, Strategy indexed poppedStrategy);\\n\\n\\t/// @notice Emitted when the withdrawal queue is updated.\\n\\t/// @param user The authorized user who triggered the set.\\n\\t/// @param replacedWithdrawalQueue The new withdrawal queue.\\n\\tevent WithdrawalQueueSet(address indexed user, Strategy[] replacedWithdrawalQueue);\\n\\n\\t/// @notice Emitted when an index in the withdrawal queue is replaced.\\n\\t/// @param user The authorized user who triggered the replacement.\\n\\t/// @param index The index of the replaced strategy in the withdrawal queue.\\n\\t/// @param replacedStrategy The strategy in the withdrawal queue that was replaced.\\n\\t/// @param replacementStrategy The strategy that overrode the replaced strategy at the index.\\n\\tevent WithdrawalQueueIndexReplaced(\\n\\t\\taddress indexed user,\\n\\t\\tuint256 index,\\n\\t\\tStrategy indexed replacedStrategy,\\n\\t\\tStrategy indexed replacementStrategy\\n\\t);\\n\\n\\t/// @notice Emitted when an index in the withdrawal queue is replaced with the tip.\\n\\t/// @param user The authorized user who triggered the replacement.\\n\\t/// @param index The index of the replaced strategy in the withdrawal queue.\\n\\t/// @param replacedStrategy The strategy in the withdrawal queue replaced by the tip.\\n\\t/// @param previousTipStrategy The previous tip of the queue that replaced the strategy.\\n\\tevent WithdrawalQueueIndexReplacedWithTip(\\n\\t\\taddress indexed user,\\n\\t\\tuint256 index,\\n\\t\\tStrategy indexed replacedStrategy,\\n\\t\\tStrategy indexed previousTipStrategy\\n\\t);\\n\\n\\t/// @notice Emitted when the strategies at two indexes are swapped.\\n\\t/// @param user The authorized user who triggered the swap.\\n\\t/// @param index1 One index involved in the swap\\n\\t/// @param index2 The other index involved in the swap.\\n\\t/// @param newStrategy1 The strategy (previously at index2) that replaced index1.\\n\\t/// @param newStrategy2 The strategy (previously at index1) that replaced index2.\\n\\tevent WithdrawalQueueIndexesSwapped(\\n\\t\\taddress indexed user,\\n\\t\\tuint256 index1,\\n\\t\\tuint256 index2,\\n\\t\\tStrategy indexed newStrategy1,\\n\\t\\tStrategy indexed newStrategy2\\n\\t);\\n\\n\\t/// @dev Withdraw a specific amount of underlying tokens from strategies in the withdrawal queue.\\n\\t/// @param underlyingAmount The amount of underlying tokens to pull into float.\\n\\t/// @dev Automatically removes depleted strategies from the withdrawal queue.\\n\\tfunction pullFromWithdrawalQueue(uint256 underlyingAmount) internal {\\n\\t\\t// We will update this variable as we pull from strategies.\\n\\t\\tuint256 amountLeftToPull = underlyingAmount;\\n\\n\\t\\t// We'll start at the tip of the queue and traverse backwards.\\n\\t\\tuint256 currentIndex = withdrawalQueue.length - 1;\\n\\n\\t\\t// Iterate in reverse so we pull from the queue in a \\\"last in, first out\\\" manner.\\n\\t\\t// Will revert due to underflow if we empty the queue before pulling the desired amount.\\n\\t\\tfor (; ; currentIndex--) {\\n\\t\\t\\t// Get the strategy at the current queue index.\\n\\t\\t\\tStrategy strategy = withdrawalQueue[currentIndex];\\n\\n\\t\\t\\t// Get the balance of the strategy before we withdraw from it.\\n\\t\\t\\tuint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n\\t\\t\\t// If the strategy is currently untrusted or was already depleted:\\n\\t\\t\\tif (!getStrategyData[strategy].trusted || strategyBalance == 0) {\\n\\t\\t\\t\\t// Remove it from the queue.\\n\\t\\t\\t\\twithdrawalQueue.pop();\\n\\n\\t\\t\\t\\temit WithdrawalQueuePopped(msg.sender, strategy);\\n\\n\\t\\t\\t\\t// Move onto the next strategy.\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// We want to pull as much as we can from the strategy, but no more than we need.\\n\\t\\t\\tuint256 amountToPull = FixedPointMathLib.min(amountLeftToPull, strategyBalance);\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\t// Compute the balance of the strategy that will remain after we withdraw.\\n\\t\\t\\t\\t// Cannot underflow as we cap the amount to pull at the strategy's balance.\\n\\t\\t\\t\\tuint256 strategyBalanceAfterWithdrawal = strategyBalance - amountToPull;\\n\\n\\t\\t\\t\\t// Without this the next harvest would count the withdrawal as a loss.\\n\\t\\t\\t\\tgetStrategyData[strategy].balance = strategyBalanceAfterWithdrawal.safeCastTo248();\\n\\n\\t\\t\\t\\t// Adjust our goal based on how much we can pull from the strategy.\\n\\t\\t\\t\\t// Cannot underflow as we cap the amount to pull at the amount left to pull.\\n\\t\\t\\t\\tamountLeftToPull -= amountToPull;\\n\\n\\t\\t\\t\\temit StrategyWithdrawal(msg.sender, strategy, amountToPull);\\n\\n\\t\\t\\t\\t// Withdraw from the strategy and revert if returns an error code.\\n\\t\\t\\t\\trequire(strategy.redeemUnderlying(amountToPull) == 0, \\\"REDEEM_FAILED\\\");\\n\\n\\t\\t\\t\\t// If we fully depleted the strategy:\\n\\t\\t\\t\\tif (strategyBalanceAfterWithdrawal == 0) {\\n\\t\\t\\t\\t\\t// Remove it from the queue.\\n\\t\\t\\t\\t\\twithdrawalQueue.pop();\\n\\n\\t\\t\\t\\t\\temit WithdrawalQueuePopped(msg.sender, strategy);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// If we've pulled all we need, exit the loop.\\n\\t\\t\\tif (amountLeftToPull == 0) break;\\n\\t\\t}\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// Account for the withdrawals done in the loop above.\\n\\t\\t\\t// Cannot underflow as the balances of some strategies cannot exceed the sum of all.\\n\\t\\t\\ttotalStrategyHoldings -= underlyingAmount;\\n\\t\\t}\\n\\n\\t\\t// Cache the Vault's balance of ETH.\\n\\t\\tuint256 ethBalance = address(this).balance;\\n\\n\\t\\t// If the Vault's underlying token is WETH compatible and we have some ETH, wrap it into WETH.\\n\\t\\tif (ethBalance != 0 && underlyingIsWETH)\\n\\t\\t\\tWETH(payable(address(UNDERLYING))).deposit{ value: ethBalance }();\\n\\t}\\n\\n\\t/// @notice Pushes a single strategy to front of the withdrawal queue.\\n\\t/// @param strategy The strategy to be inserted at the front of the withdrawal queue.\\n\\t/// @dev Strategies that are untrusted, duplicated, or have no balance are\\n\\t/// filtered out when encountered at withdrawal time, not validated upfront.\\n\\tfunction pushToWithdrawalQueue(Strategy strategy) external requiresAuth {\\n\\t\\t// Push the strategy to the front of the queue.\\n\\t\\twithdrawalQueue.push(strategy);\\n\\n\\t\\temit WithdrawalQueuePushed(msg.sender, strategy);\\n\\t}\\n\\n\\t/// @notice Removes the strategy at the tip of the withdrawal queue.\\n\\t/// @dev Be careful, another authorized user could push a different strategy\\n\\t/// than expected to the queue while a popFromWithdrawalQueue transaction is pending.\\n\\tfunction popFromWithdrawalQueue() external requiresAuth {\\n\\t\\t// Get the (soon to be) popped strategy.\\n\\t\\tStrategy poppedStrategy = withdrawalQueue[withdrawalQueue.length - 1];\\n\\n\\t\\t// Pop the first strategy in the queue.\\n\\t\\twithdrawalQueue.pop();\\n\\n\\t\\temit WithdrawalQueuePopped(msg.sender, poppedStrategy);\\n\\t}\\n\\n\\t/// @notice Sets a new withdrawal queue.\\n\\t/// @param newQueue The new withdrawal queue.\\n\\t/// @dev Strategies that are untrusted, duplicated, or have no balance are\\n\\t/// filtered out when encountered at withdrawal time, not validated upfront.\\n\\tfunction setWithdrawalQueue(Strategy[] calldata newQueue) external requiresAuth {\\n\\t\\t// Replace the withdrawal queue.\\n\\t\\twithdrawalQueue = newQueue;\\n\\n\\t\\temit WithdrawalQueueSet(msg.sender, newQueue);\\n\\t}\\n\\n\\t/// @notice Replaces an index in the withdrawal queue with another strategy.\\n\\t/// @param index The index in the queue to replace.\\n\\t/// @param replacementStrategy The strategy to override the index with.\\n\\t/// @dev Strategies that are untrusted, duplicated, or have no balance are\\n\\t/// filtered out when encountered at withdrawal time, not validated upfront.\\n\\tfunction replaceWithdrawalQueueIndex(uint256 index, Strategy replacementStrategy)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Get the (soon to be) replaced strategy.\\n\\t\\tStrategy replacedStrategy = withdrawalQueue[index];\\n\\n\\t\\t// Update the index with the replacement strategy.\\n\\t\\twithdrawalQueue[index] = replacementStrategy;\\n\\n\\t\\temit WithdrawalQueueIndexReplaced(msg.sender, index, replacedStrategy, replacementStrategy);\\n\\t}\\n\\n\\t/// @notice Moves the strategy at the tip of the queue to the specified index and pop the tip off the queue.\\n\\t/// @param index The index of the strategy in the withdrawal queue to replace with the tip.\\n\\tfunction replaceWithdrawalQueueIndexWithTip(uint256 index) external requiresAuth {\\n\\t\\t// Get the (soon to be) previous tip and strategy we will replace at the index.\\n\\t\\tStrategy previousTipStrategy = withdrawalQueue[withdrawalQueue.length - 1];\\n\\t\\tStrategy replacedStrategy = withdrawalQueue[index];\\n\\n\\t\\t// Replace the index specified with the tip of the queue.\\n\\t\\twithdrawalQueue[index] = previousTipStrategy;\\n\\n\\t\\t// Remove the now duplicated tip from the array.\\n\\t\\twithdrawalQueue.pop();\\n\\n\\t\\temit WithdrawalQueueIndexReplacedWithTip(\\n\\t\\t\\tmsg.sender,\\n\\t\\t\\tindex,\\n\\t\\t\\treplacedStrategy,\\n\\t\\t\\tpreviousTipStrategy\\n\\t\\t);\\n\\t}\\n\\n\\t/// @notice Swaps two indexes in the withdrawal queue.\\n\\t/// @param index1 One index involved in the swap\\n\\t/// @param index2 The other index involved in the swap.\\n\\tfunction swapWithdrawalQueueIndexes(uint256 index1, uint256 index2) external requiresAuth {\\n\\t\\t// Get the (soon to be) new strategies at each index.\\n\\t\\tStrategy newStrategy2 = withdrawalQueue[index1];\\n\\t\\tStrategy newStrategy1 = withdrawalQueue[index2];\\n\\n\\t\\t// Swap the strategies at both indexes.\\n\\t\\twithdrawalQueue[index1] = newStrategy1;\\n\\t\\twithdrawalQueue[index2] = newStrategy2;\\n\\n\\t\\temit WithdrawalQueueIndexesSwapped(msg.sender, index1, index2, newStrategy1, newStrategy2);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                         SEIZE STRATEGY LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after a strategy is seized.\\n\\t/// @param user The authorized user who triggered the seize.\\n\\t/// @param strategy The strategy that was seized.\\n\\tevent StrategySeized(address indexed user, Strategy indexed strategy);\\n\\n\\t/// @notice Seizes a strategy.\\n\\t/// @param strategy The strategy to seize.\\n\\t/// @dev Intended for use in emergencies or other extraneous situations where the\\n\\t/// strategy requires interaction outside of the Vault's standard operating procedures.\\n\\tfunction seizeStrategy(Strategy strategy) external requiresAuth {\\n\\t\\t// A strategy must be trusted before it can be seized.\\n\\t\\trequire(getStrategyData[strategy].trusted, \\\"UNTRUSTED_STRATEGY\\\");\\n\\n\\t\\t// Get the strategy's last reported balance of underlying tokens.\\n\\t\\tuint256 strategyBalance = getStrategyData[strategy].balance;\\n\\n\\t\\t// If the strategy's balance exceeds the Vault's current\\n\\t\\t// holdings, instantly unlock any remaining locked profit.\\n\\t\\tif (strategyBalance > totalHoldings()) maxLockedProfit = 0;\\n\\n\\t\\t// Set the strategy's balance to 0.\\n\\t\\tgetStrategyData[strategy].balance = 0;\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// Decrease totalStrategyHoldings to account for the seize.\\n\\t\\t\\t// Cannot underflow as the balance of one strategy will never exceed the sum of all.\\n\\t\\t\\ttotalStrategyHoldings -= strategyBalance;\\n\\t\\t}\\n\\n\\t\\temit StrategySeized(msg.sender, strategy);\\n\\n\\t\\t// Transfer all of the strategy's tokens to the caller.\\n\\t\\tERC20(strategy).safeTransfer(msg.sender, strategy.balanceOf(address(this)));\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                             FEE CLAIM LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted after fees are claimed.\\n\\t/// @param user The authorized user who claimed the fees.\\n\\t/// @param rvTokenAmount The amount of rvTokens that were claimed.\\n\\tevent FeesClaimed(address indexed user, uint256 rvTokenAmount);\\n\\n\\t/// @notice Claims fees accrued from harvests.\\n\\t/// @param rvTokenAmount The amount of rvTokens to claim.\\n\\t/// @dev Accrued fees are measured as rvTokens held by the Vault.\\n\\tfunction claimFees(uint256 rvTokenAmount) external requiresAuth {\\n\\t\\temit FeesClaimed(msg.sender, rvTokenAmount);\\n\\n\\t\\t// Transfer the provided amount of rvTokens to the caller.\\n\\t\\tERC20(this).safeTransfer(msg.sender, rvTokenAmount);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                    INITIALIZATION AND DESTRUCTION LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when the Vault is initialized.\\n\\t/// @param user The authorized user who triggered the initialization.\\n\\tevent Initialized(address indexed user);\\n\\n\\t/// @notice Whether the Vault has been initialized yet.\\n\\t/// @dev Can go from false to true, never from true to false.\\n\\tbool public isInitialized;\\n\\n\\t/// @notice Initializes the Vault, enabling it to receive deposits.\\n\\t/// @dev All critical parameters must already be set before calling.\\n\\tfunction initialize() external requiresAuth {\\n\\t\\t// Ensure the Vault has not already been initialized.\\n\\t\\trequire(!isInitialized, \\\"ALREADY_INITIALIZED\\\");\\n\\n\\t\\t// Mark the Vault as initialized.\\n\\t\\tisInitialized = true;\\n\\n\\t\\t// Open for deposits.\\n\\t\\ttotalSupply = 0;\\n\\n\\t\\temit Initialized(msg.sender);\\n\\t}\\n\\n\\t/// @notice Self destructs a Vault, enabling it to be redeployed.\\n\\t/// @dev Caller will receive any ETH held as float in the Vault.\\n\\tfunction destroy() external requiresAuth {\\n\\t\\tselfdestruct(payable(msg.sender));\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                          RECIEVE ETHER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @dev Required for the Vault to receive unwrapped ETH.\\n\\treceive() external payable {}\\n}\\n\",\"keccak256\":\"0x9edb7b5020282788b8ca68d7523c3b3b0d49bf68b584517d01992feec52a72ef\",\"license\":\"AGPL-3.0\"},\"src/vault/interfaces/Strategy.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\nimport { ERC20 } from \\\"solmate/src/tokens/ERC20.sol\\\";\\n\\n/// @notice Minimal interface for Vault compatible strategies.\\n/// @dev Designed for out of the box compatibility with Fuse cTokens.\\n/// @dev Like cTokens, strategies must be transferrable ERC20s.\\nabstract contract Strategy is ERC20 {\\n\\t/// @notice Returns whether the strategy accepts ETH or an ERC20.\\n\\t/// @return True if the strategy accepts ETH, false otherwise.\\n\\t/// @dev Only present in Fuse cTokens, not Compound cTokens.\\n\\tfunction isCEther() external view virtual returns (bool);\\n\\n\\t/// @notice Withdraws a specific amount of underlying tokens from the strategy.\\n\\t/// @param amount The amount of underlying tokens to withdraw.\\n\\t/// @return An error code, or 0 if the withdrawal was successful.\\n\\tfunction redeemUnderlying(uint256 amount) external virtual returns (uint256);\\n\\n\\t/// @notice Returns a user's strategy balance in underlying tokens.\\n\\t/// @param user The user to get the underlying balance of.\\n\\t/// @return The user's strategy balance in underlying tokens.\\n\\t/// @dev May mutate the state of the strategy by accruing interest.\\n\\tfunction balanceOfUnderlying(address user) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ERC20s.\\n/// @dev Designed for out of the box compatibility with Fuse cERC20s.\\nabstract contract ERC20Strategy is Strategy {\\n\\t/// @notice Returns the underlying ERC20 token the strategy accepts.\\n\\t/// @return The underlying ERC20 token the strategy accepts.\\n\\tfunction underlying() external view virtual returns (ERC20);\\n\\n\\t/// @notice Deposit a specific amount of underlying tokens into the strategy.\\n\\t/// @param amount The amount of underlying tokens to deposit.\\n\\t/// @return An error code, or 0 if the deposit was successful.\\n\\tfunction mint(uint256 amount) external virtual returns (uint256);\\n}\\n\\n/// @notice Minimal interface for Vault strategies that accept ETH.\\n/// @dev Designed for out of the box compatibility with Fuse cEther.\\nabstract contract ETHStrategy is Strategy {\\n\\t/// @notice Deposit a specific amount of ETH into the strategy.\\n\\t/// @dev The amount of ETH is specified via msg.value. Reverts on error.\\n\\tfunction mint() external payable virtual;\\n}\\n\",\"keccak256\":\"0xd4d9b8156bf24e60585bdd7e74e7f343a59440fa73b18d7b46b1b80e585f39c6\",\"license\":\"AGPL-3.0\"},\"src/vault/modules/VaultConfigurationModule.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity 0.8.10;\\n\\nimport { Auth, Authority } from \\\"solmate/src/auth/Auth.sol\\\";\\n\\nimport { Vault } from \\\"../Vault.sol\\\";\\n\\n/// @title Rari Vault Configuration Module\\n/// @author Transmissions11 and JetJadeja\\n/// @notice Module for configuring Vault parameters.\\ncontract VaultConfigurationModule is Auth {\\n\\t/*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Creates a Vault configuration module.\\n\\t/// @param _owner The owner of the module.\\n\\t/// @param _authority The Authority of the module.\\n\\tconstructor(address _owner, Authority _authority) Auth(_owner, _authority) {}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                  DEFAULT VAULT PARAMETER CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when the default fee percentage is updated.\\n\\t/// @param newDefaultFeePercent The new default fee percentage.\\n\\tevent DefaultFeePercentUpdated(uint256 newDefaultFeePercent);\\n\\n\\t/// @notice Emitted when the default harvest delay is updated.\\n\\t/// @param newDefaultHarvestDelay The new default harvest delay.\\n\\tevent DefaultHarvestDelayUpdated(uint64 newDefaultHarvestDelay);\\n\\n\\t/// @notice Emitted when the default harvest window is updated.\\n\\t/// @param newDefaultHarvestWindow The new default harvest window.\\n\\tevent DefaultHarvestWindowUpdated(uint128 newDefaultHarvestWindow);\\n\\n\\t/// @notice Emitted when the default target float percentage is updated.\\n\\t/// @param newDefaultTargetFloatPercent The new default target float percentage.\\n\\tevent DefaultTargetFloatPercentUpdated(uint256 newDefaultTargetFloatPercent);\\n\\n\\t/// @notice The default fee percentage for Vaults.\\n\\tuint256 public defaultFeePercent;\\n\\n\\t/// @notice The default harvest delay for Vaults.\\n\\tuint64 public defaultHarvestDelay;\\n\\n\\t/// @notice The default harvest window for Vaults.\\n\\tuint128 public defaultHarvestWindow;\\n\\n\\t/// @notice The default target float percentage for Vaults.\\n\\tuint256 public defaultTargetFloatPercent;\\n\\n\\t/// @notice Sets the default fee percentage for Vaults.\\n\\t/// @param newDefaultFeePercent The new default fee percentage to set.\\n\\tfunction setDefaultFeePercent(uint256 newDefaultFeePercent) external requiresAuth {\\n\\t\\t// Update the default fee percentage.\\n\\t\\tdefaultFeePercent = newDefaultFeePercent;\\n\\n\\t\\temit DefaultFeePercentUpdated(newDefaultFeePercent);\\n\\t}\\n\\n\\t/// @notice Sets the default harvest delay for Vaults.\\n\\t/// @param newDefaultHarvestDelay The new default harvest delay to set.\\n\\tfunction setDefaultHarvestDelay(uint64 newDefaultHarvestDelay) external requiresAuth {\\n\\t\\t// Update the default harvest delay.\\n\\t\\tdefaultHarvestDelay = newDefaultHarvestDelay;\\n\\n\\t\\temit DefaultHarvestDelayUpdated(newDefaultHarvestDelay);\\n\\t}\\n\\n\\t/// @notice Sets the default harvest window for Vaults.\\n\\t/// @param newDefaultHarvestWindow The new default harvest window to set.\\n\\tfunction setDefaultHarvestWindow(uint128 newDefaultHarvestWindow) external requiresAuth {\\n\\t\\t// Update the default harvest window.\\n\\t\\tdefaultHarvestWindow = newDefaultHarvestWindow;\\n\\n\\t\\temit DefaultHarvestWindowUpdated(newDefaultHarvestWindow);\\n\\t}\\n\\n\\t/// @notice Sets the default target float percentage for Vaults.\\n\\t/// @param newDefaultTargetFloatPercent The new default target float percentage to set.\\n\\tfunction setDefaultTargetFloatPercent(uint256 newDefaultTargetFloatPercent)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Update the default target float percentage.\\n\\t\\tdefaultTargetFloatPercent = newDefaultTargetFloatPercent;\\n\\n\\t\\temit DefaultTargetFloatPercentUpdated(newDefaultTargetFloatPercent);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                  CUSTOM VAULT PARAMETER CONFIGURATION\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Emitted when a Vault has its custom fee percentage set/updated.\\n\\t/// @param vault The Vault that had its custom fee percentage set/updated.\\n\\t/// @param newCustomFeePercent The new custom fee percentage for the Vault.\\n\\tevent CustomFeePercentUpdated(Vault indexed vault, uint256 newCustomFeePercent);\\n\\n\\t/// @notice Emitted when a Vault has its custom harvest delay set/updated.\\n\\t/// @param vault The Vault that had its custom harvest delay set/updated.\\n\\t/// @param newCustomHarvestDelay The new custom harvest delay for the Vault.\\n\\tevent CustomHarvestDelayUpdated(Vault indexed vault, uint256 newCustomHarvestDelay);\\n\\n\\t/// @notice Emitted when a Vault has its custom harvest window set/updated.\\n\\t/// @param vault The Vault that had its custom harvest window set/updated.\\n\\t/// @param newCustomHarvestWindow The new custom harvest window for the Vault.\\n\\tevent CustomHarvestWindowUpdated(Vault indexed vault, uint256 newCustomHarvestWindow);\\n\\n\\t/// @notice Emitted when a Vault has its custom target float percentage set/updated.\\n\\t/// @param vault The Vault that had its custom target float percentage set/updated.\\n\\t/// @param newCustomTargetFloatPercent The new custom target float percentage for the Vault.\\n\\tevent CustomTargetFloatPercentUpdated(Vault indexed vault, uint256 newCustomTargetFloatPercent);\\n\\n\\t/// @notice Maps Vaults to their custom fee percentage.\\n\\t/// @dev Will be 0 if there is no custom fee percentage for the Vault.\\n\\tmapping(Vault => uint256) public getVaultCustomFeePercent;\\n\\n\\t/// @notice Maps Vaults to their custom harvest delay.\\n\\t/// @dev Will be 0 if there is no custom harvest delay for the Vault.\\n\\tmapping(Vault => uint64) public getVaultCustomHarvestDelay;\\n\\n\\t/// @notice Maps Vaults to their custom harvest window.\\n\\t/// @dev Will be 0 if there is no custom harvest window for the Vault.\\n\\tmapping(Vault => uint128) public getVaultCustomHarvestWindow;\\n\\n\\t/// @notice Maps Vaults to their custom target float percentage.\\n\\t/// @dev Will be 0 if there is no custom target float percentage for the Vault.\\n\\tmapping(Vault => uint256) public getVaultCustomTargetFloatPercent;\\n\\n\\t/// @notice Sets the custom fee percentage for the Vault.\\n\\t/// @param vault The Vault to set the custom fee percentage for.\\n\\t/// @param customFeePercent The new custom fee percentage to set.\\n\\tfunction setVaultCustomFeePercent(Vault vault, uint256 customFeePercent) external requiresAuth {\\n\\t\\t// Update the Vault's custom fee percentage.\\n\\t\\tgetVaultCustomFeePercent[vault] = customFeePercent;\\n\\n\\t\\temit CustomFeePercentUpdated(vault, customFeePercent);\\n\\t}\\n\\n\\t/// @notice Sets the custom harvest delay for the Vault.\\n\\t/// @param vault The Vault to set the custom harvest delay for.\\n\\t/// @param customHarvestDelay The new custom harvest delay to set.\\n\\tfunction setVaultCustomHarvestDelay(Vault vault, uint64 customHarvestDelay)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Update the Vault's custom harvest delay.\\n\\t\\tgetVaultCustomHarvestDelay[vault] = customHarvestDelay;\\n\\n\\t\\temit CustomHarvestDelayUpdated(vault, customHarvestDelay);\\n\\t}\\n\\n\\t/// @notice Sets the custom harvest window for the Vault.\\n\\t/// @param vault The Vault to set the custom harvest window for.\\n\\t/// @param customHarvestWindow The new custom harvest window to set.\\n\\tfunction setVaultCustomHarvestWindow(Vault vault, uint128 customHarvestWindow)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Update the Vault's custom harvest window.\\n\\t\\tgetVaultCustomHarvestWindow[vault] = customHarvestWindow;\\n\\n\\t\\temit CustomHarvestWindowUpdated(vault, customHarvestWindow);\\n\\t}\\n\\n\\t/// @notice Sets the custom target float percentage for the Vault.\\n\\t/// @param vault The Vault to set the custom target float percentage for.\\n\\t/// @param customTargetFloatPercent The new custom target float percentage to set.\\n\\tfunction setVaultCustomTargetFloatPercent(Vault vault, uint256 customTargetFloatPercent)\\n\\t\\texternal\\n\\t\\trequiresAuth\\n\\t{\\n\\t\\t// Update the Vault's custom target float percentage.\\n\\t\\tgetVaultCustomTargetFloatPercent[vault] = customTargetFloatPercent;\\n\\n\\t\\temit CustomTargetFloatPercentUpdated(vault, customTargetFloatPercent);\\n\\t}\\n\\n\\t/*///////////////////////////////////////////////////////////////\\n                       VAULT PARAMETER SYNC LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n\\t/// @notice Syncs a Vault's fee percentage with either the Vault's custom fee\\n\\t/// percentage or the default fee percentage if a custom percentage is not set.\\n\\t/// @param vault The Vault to sync the fee percentage for.\\n\\tfunction syncFeePercent(Vault vault) external {\\n\\t\\t// Get the Vault's custom fee percentage.\\n\\t\\tuint256 customFeePercent = getVaultCustomFeePercent[vault];\\n\\n\\t\\t// Set the Vault's fee percentage to the custom fee percentage\\n\\t\\t// or the default fee percentage if a custom percentage isn't set.\\n\\t\\tvault.setFeePercent(customFeePercent == 0 ? defaultFeePercent : customFeePercent);\\n\\t}\\n\\n\\t/// @notice Syncs a Vault's harvest delay with either the Vault's custom\\n\\t/// harvest delay or the default harvest delay if a custom delay is not set.\\n\\t/// @param vault The Vault to sync the harvest delay for.\\n\\tfunction syncHarvestDelay(Vault vault) external {\\n\\t\\t// Get the Vault's custom harvest delay.\\n\\t\\tuint64 customHarvestDelay = getVaultCustomHarvestDelay[vault];\\n\\n\\t\\t// Set the Vault's harvest delay to the custom harvest delay\\n\\t\\t// or the default harvest delay if a custom delay isn't set.\\n\\t\\tvault.setHarvestDelay(customHarvestDelay == 0 ? defaultHarvestDelay : customHarvestDelay);\\n\\t}\\n\\n\\t/// @notice Syncs a Vault's harvest window with either the Vault's custom\\n\\t/// harvest window or the default harvest window if a custom window is not set.\\n\\t/// @param vault The Vault to sync the harvest window for.\\n\\tfunction syncHarvestWindow(Vault vault) external {\\n\\t\\t// Get the Vault's custom harvest window.\\n\\t\\tuint128 customHarvestWindow = getVaultCustomHarvestWindow[vault];\\n\\n\\t\\t// Set the Vault's harvest window to the custom harvest window\\n\\t\\t// or the default harvest window if a custom window isn't set.\\n\\t\\tvault.setHarvestWindow(\\n\\t\\t\\tcustomHarvestWindow == 0 ? defaultHarvestWindow : customHarvestWindow\\n\\t\\t);\\n\\t}\\n\\n\\t/// @notice Syncs a Vault's target float percentage with either the Vault's custom target\\n\\t/// float percentage or the default target float percentage if a custom percentage is not set.\\n\\t/// @param vault The Vault to sync the target float percentage for.\\n\\tfunction syncTargetFloatPercent(Vault vault) external {\\n\\t\\t// Get the Vault's custom target float percentage.\\n\\t\\tuint256 customTargetFloatPercent = getVaultCustomTargetFloatPercent[vault];\\n\\n\\t\\t// Set the Vault's target float percentage to the custom target float percentage\\n\\t\\t// or the default target float percentage if a custom percentage isn't set.\\n\\t\\tvault.setTargetFloatPercent(\\n\\t\\t\\tcustomTargetFloatPercent == 0 ? defaultTargetFloatPercent : customTargetFloatPercent\\n\\t\\t);\\n\\t}\\n}\\n\",\"keccak256\":\"0x1ed2b6021ae3e5a4d49461f88ae7db0d4846e639c2af868168aaed00df4bc4d4\",\"license\":\"AGPL-3.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051610deb380380610deb83398101604081905261002f916100de565b600080546001600160a01b03199081166001600160a01b038581169182178455600180549093169085161790915560405184928492917f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b9190a26040516001600160a01b038216907f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250505050610118565b6001600160a01b03811681146100db57600080fd5b50565b600080604083850312156100f157600080fd5b82516100fc816100c6565b602084015190925061010d816100c6565b809150509250929050565b610cc4806101276000396000f3fe608060405234801561001057600080fd5b50600436106101285760003560e01c806305d7282c1461012d57806313af4035146101425780632487bbff14610155578063261d26b6146101945780632b4b2753146101ab5780633295ce96146101be5780634022d941146101d15780634ce908f4146101e45780635607702f146101f75780635fad65b01461020a5780636eae95131461022a5780636f8409321461024a5780637a9e5e4b146102805780638da5cb5b14610293578063ac345d03146102be578063af54da91146102d1578063b5ef8b1e146102e4578063b7c392c8146102fe578063bc3e38fa14610311578063bf7e214f14610324578063c9b639d214610337578063dd55002d1461034a578063e7926d5c1461035d578063e7d9934b14610366575b600080fd5b61014061013b366004610aeb565b610379565b005b610140610150366004610b17565b61040d565b61017e610163366004610b17565b6007602052600090815260409020546001600160801b031681565b60405161018b9190610b3b565b60405180910390f35b61019d60045481565b60405190815260200161018b565b6101406101b9366004610b4f565b610487565b6101406101cc366004610b84565b6104f5565b6101406101df366004610bb6565b61057b565b6101406101f2366004610bd1565b6105f8565b610140610205366004610b17565b61068b565b61019d610218366004610b17565b60086020526000908152604090205481565b61019d610238366004610b17565b60056020526000908152604090205481565b610273610258366004610b17565b6006602052600090815260409020546001600160401b031681565b60405161018b9190610c06565b61014061028e366004610b17565b61071e565b6000546102a6906001600160a01b031681565b6040516001600160a01b03909116815260200161018b565b6101406102cc366004610b17565b61079a565b6101406102df366004610c1a565b6107e7565b60035461017e90600160401b90046001600160801b031681565b61014061030c366004610b17565b61087a565b61014061031f366004610aeb565b6108c6565b6001546102a6906001600160a01b031681565b600354610273906001600160401b031681565b610140610358366004610b4f565b610945565b61019d60025481565b610140610374366004610b17565b6109ac565b61038f336000356001600160e01b031916610a10565b6103b45760405162461bcd60e51b81526004016103ab90610c46565b60405180910390fd5b6001600160a01b03821660008181526008602052604090819020839055517fd710c46434b3517342d3119bd7db2b06b533042ad40997249339dc52a84ef87c906104019084815260200190565b60405180910390a25050565b610423336000356001600160e01b031916610a10565b61043f5760405162461bcd60e51b81526004016103ab90610c46565b600080546001600160a01b0319166001600160a01b038316908117825560405190917f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b91a250565b61049d336000356001600160e01b031916610a10565b6104b95760405162461bcd60e51b81526004016103ab90610c46565b60048190556040518181527ff6ac39ac7a3a4a8e0820f1f0db868216520c8194410993c9a4256df18f2c1648906020015b60405180910390a150565b61050b336000356001600160e01b031916610a10565b6105275760405162461bcd60e51b81526004016103ab90610c46565b60038054600160401b600160c01b031916600160401b6001600160801b038416021790556040517f54707f3cc4f1f275c1ca6cc5ea22b131da3e4e3187055769a011b8bfa3fe7e2c906104ea908390610b3b565b610591336000356001600160e01b031916610a10565b6105ad5760405162461bcd60e51b81526004016103ab90610c46565b600380546001600160401b0319166001600160401b0383161790556040517fd49755c36f0046593fc57349146d19a3d849086b9f6f07f5262bbe51338dd020906104ea908390610c06565b61060e336000356001600160e01b031916610a10565b61062a5760405162461bcd60e51b81526004016103ab90610c46565b6001600160a01b0382166000818152600760205260409081902080546001600160801b0319166001600160801b038516179055517f020f4b532e50c21e70f84cf5b279d8b67380fe88a156bc883d11cbd3c906460890610401908490610b3b565b6001600160a01b0381166000818152600660205260409020546001600160401b031690637b72aeb982156106bf57826106cc565b6003546001600160401b03165b6040518263ffffffff1660e01b81526004016106e89190610c06565b600060405180830381600087803b15801561070257600080fd5b505af1158015610716573d6000803e3d6000fd5b505050505050565b610734336000356001600160e01b031916610a10565b6107505760405162461bcd60e51b81526004016103ab90610c46565b600180546001600160a01b0319166001600160a01b0383169081179091556040517f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250565b6001600160a01b0381166000818152600860205260409020549063bd662f8882156107c557826107c9565b6004545b6040518263ffffffff1660e01b81526004016106e891815260200190565b6107fd336000356001600160e01b031916610a10565b6108195760405162461bcd60e51b81526004016103ab90610c46565b6001600160a01b0382166000818152600660205260409081902080546001600160401b0319166001600160401b038516179055517f0d239ace1084ebc7a2681e317ee23b0ddccdfb63175585667a8cf7d6771aa36e90610401908490610c06565b6001600160a01b03811660008181526005602052604090205490637ce3489b82156108a557826107c9565b6002546040518263ffffffff1660e01b81526004016106e891815260200190565b6108dc336000356001600160e01b031916610a10565b6108f85760405162461bcd60e51b81526004016103ab90610c46565b6001600160a01b03821660008181526005602052604090819020839055517f1d66532ea81d485f8eedbb61c45181fc69b2cbf6f5b05f741b0d3d54d80f9ea9906104019084815260200190565b61095b336000356001600160e01b031916610a10565b6109775760405162461bcd60e51b81526004016103ab90610c46565b60028190556040518181527f1ba0c7196822b2db3b609b1fbf446c9e0857b6864a4143877b6eb5fa9e9d2bb7906020016104ea565b6001600160a01b0381166000818152600760205260409020546001600160801b0316906307b35d1d82156109e057826109f4565b600354600160401b90046001600160801b03165b6040518263ffffffff1660e01b81526004016106e89190610b3b565b6001546000906001600160a01b03168015610ab95760405163b700961360e01b81526001600160a01b0385811660048301523060248301526001600160e01b03198516604483015282169063b700961390606401602060405180830381865afa925050508015610a9d575060408051601f3d908101601f19168201909252610a9a91810190610c6c565b60015b610aa657610ab9565b8015610ab757600192505050610acd565b505b50506000546001600160a01b038381169116145b92915050565b6001600160a01b0381168114610ae857600080fd5b50565b60008060408385031215610afe57600080fd5b8235610b0981610ad3565b946020939093013593505050565b600060208284031215610b2957600080fd5b8135610b3481610ad3565b9392505050565b6001600160801b0391909116815260200190565b600060208284031215610b6157600080fd5b5035919050565b80356001600160801b0381168114610b7f57600080fd5b919050565b600060208284031215610b9657600080fd5b610b3482610b68565b80356001600160401b0381168114610b7f57600080fd5b600060208284031215610bc857600080fd5b610b3482610b9f565b60008060408385031215610be457600080fd5b8235610bef81610ad3565b9150610bfd60208401610b68565b90509250929050565b6001600160401b0391909116815260200190565b60008060408385031215610c2d57600080fd5b8235610c3881610ad3565b9150610bfd60208401610b9f565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b600060208284031215610c7e57600080fd5b81518015158114610b3457600080fdfea26469706673582212206c622dea89a10a9c9e772d46a9ebaba5f0f43f428144a34d9332442a5403b3c764736f6c634300080a0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101285760003560e01c806305d7282c1461012d57806313af4035146101425780632487bbff14610155578063261d26b6146101945780632b4b2753146101ab5780633295ce96146101be5780634022d941146101d15780634ce908f4146101e45780635607702f146101f75780635fad65b01461020a5780636eae95131461022a5780636f8409321461024a5780637a9e5e4b146102805780638da5cb5b14610293578063ac345d03146102be578063af54da91146102d1578063b5ef8b1e146102e4578063b7c392c8146102fe578063bc3e38fa14610311578063bf7e214f14610324578063c9b639d214610337578063dd55002d1461034a578063e7926d5c1461035d578063e7d9934b14610366575b600080fd5b61014061013b366004610aeb565b610379565b005b610140610150366004610b17565b61040d565b61017e610163366004610b17565b6007602052600090815260409020546001600160801b031681565b60405161018b9190610b3b565b60405180910390f35b61019d60045481565b60405190815260200161018b565b6101406101b9366004610b4f565b610487565b6101406101cc366004610b84565b6104f5565b6101406101df366004610bb6565b61057b565b6101406101f2366004610bd1565b6105f8565b610140610205366004610b17565b61068b565b61019d610218366004610b17565b60086020526000908152604090205481565b61019d610238366004610b17565b60056020526000908152604090205481565b610273610258366004610b17565b6006602052600090815260409020546001600160401b031681565b60405161018b9190610c06565b61014061028e366004610b17565b61071e565b6000546102a6906001600160a01b031681565b6040516001600160a01b03909116815260200161018b565b6101406102cc366004610b17565b61079a565b6101406102df366004610c1a565b6107e7565b60035461017e90600160401b90046001600160801b031681565b61014061030c366004610b17565b61087a565b61014061031f366004610aeb565b6108c6565b6001546102a6906001600160a01b031681565b600354610273906001600160401b031681565b610140610358366004610b4f565b610945565b61019d60025481565b610140610374366004610b17565b6109ac565b61038f336000356001600160e01b031916610a10565b6103b45760405162461bcd60e51b81526004016103ab90610c46565b60405180910390fd5b6001600160a01b03821660008181526008602052604090819020839055517fd710c46434b3517342d3119bd7db2b06b533042ad40997249339dc52a84ef87c906104019084815260200190565b60405180910390a25050565b610423336000356001600160e01b031916610a10565b61043f5760405162461bcd60e51b81526004016103ab90610c46565b600080546001600160a01b0319166001600160a01b038316908117825560405190917f4ffd725fc4a22075e9ec71c59edf9c38cdeb588a91b24fc5b61388c5be41282b91a250565b61049d336000356001600160e01b031916610a10565b6104b95760405162461bcd60e51b81526004016103ab90610c46565b60048190556040518181527ff6ac39ac7a3a4a8e0820f1f0db868216520c8194410993c9a4256df18f2c1648906020015b60405180910390a150565b61050b336000356001600160e01b031916610a10565b6105275760405162461bcd60e51b81526004016103ab90610c46565b60038054600160401b600160c01b031916600160401b6001600160801b038416021790556040517f54707f3cc4f1f275c1ca6cc5ea22b131da3e4e3187055769a011b8bfa3fe7e2c906104ea908390610b3b565b610591336000356001600160e01b031916610a10565b6105ad5760405162461bcd60e51b81526004016103ab90610c46565b600380546001600160401b0319166001600160401b0383161790556040517fd49755c36f0046593fc57349146d19a3d849086b9f6f07f5262bbe51338dd020906104ea908390610c06565b61060e336000356001600160e01b031916610a10565b61062a5760405162461bcd60e51b81526004016103ab90610c46565b6001600160a01b0382166000818152600760205260409081902080546001600160801b0319166001600160801b038516179055517f020f4b532e50c21e70f84cf5b279d8b67380fe88a156bc883d11cbd3c906460890610401908490610b3b565b6001600160a01b0381166000818152600660205260409020546001600160401b031690637b72aeb982156106bf57826106cc565b6003546001600160401b03165b6040518263ffffffff1660e01b81526004016106e89190610c06565b600060405180830381600087803b15801561070257600080fd5b505af1158015610716573d6000803e3d6000fd5b505050505050565b610734336000356001600160e01b031916610a10565b6107505760405162461bcd60e51b81526004016103ab90610c46565b600180546001600160a01b0319166001600160a01b0383169081179091556040517f2f658b440c35314f52658ea8a740e05b284cdc84dc9ae01e891f21b8933e7cad90600090a250565b6001600160a01b0381166000818152600860205260409020549063bd662f8882156107c557826107c9565b6004545b6040518263ffffffff1660e01b81526004016106e891815260200190565b6107fd336000356001600160e01b031916610a10565b6108195760405162461bcd60e51b81526004016103ab90610c46565b6001600160a01b0382166000818152600660205260409081902080546001600160401b0319166001600160401b038516179055517f0d239ace1084ebc7a2681e317ee23b0ddccdfb63175585667a8cf7d6771aa36e90610401908490610c06565b6001600160a01b03811660008181526005602052604090205490637ce3489b82156108a557826107c9565b6002546040518263ffffffff1660e01b81526004016106e891815260200190565b6108dc336000356001600160e01b031916610a10565b6108f85760405162461bcd60e51b81526004016103ab90610c46565b6001600160a01b03821660008181526005602052604090819020839055517f1d66532ea81d485f8eedbb61c45181fc69b2cbf6f5b05f741b0d3d54d80f9ea9906104019084815260200190565b61095b336000356001600160e01b031916610a10565b6109775760405162461bcd60e51b81526004016103ab90610c46565b60028190556040518181527f1ba0c7196822b2db3b609b1fbf446c9e0857b6864a4143877b6eb5fa9e9d2bb7906020016104ea565b6001600160a01b0381166000818152600760205260409020546001600160801b0316906307b35d1d82156109e057826109f4565b600354600160401b90046001600160801b03165b6040518263ffffffff1660e01b81526004016106e89190610b3b565b6001546000906001600160a01b03168015610ab95760405163b700961360e01b81526001600160a01b0385811660048301523060248301526001600160e01b03198516604483015282169063b700961390606401602060405180830381865afa925050508015610a9d575060408051601f3d908101601f19168201909252610a9a91810190610c6c565b60015b610aa657610ab9565b8015610ab757600192505050610acd565b505b50506000546001600160a01b038381169116145b92915050565b6001600160a01b0381168114610ae857600080fd5b50565b60008060408385031215610afe57600080fd5b8235610b0981610ad3565b946020939093013593505050565b600060208284031215610b2957600080fd5b8135610b3481610ad3565b9392505050565b6001600160801b0391909116815260200190565b600060208284031215610b6157600080fd5b5035919050565b80356001600160801b0381168114610b7f57600080fd5b919050565b600060208284031215610b9657600080fd5b610b3482610b68565b80356001600160401b0381168114610b7f57600080fd5b600060208284031215610bc857600080fd5b610b3482610b9f565b60008060408385031215610be457600080fd5b8235610bef81610ad3565b9150610bfd60208401610b68565b90509250929050565b6001600160401b0391909116815260200190565b60008060408385031215610c2d57600080fd5b8235610c3881610ad3565b9150610bfd60208401610b9f565b6020808252600c908201526b15539055551213d49256915160a21b604082015260600190565b600060208284031215610c7e57600080fd5b81518015158114610b3457600080fdfea26469706673582212206c622dea89a10a9c9e772d46a9ebaba5f0f43f428144a34d9332442a5403b3c764736f6c634300080a0033",
  "devdoc": {
    "author": "Transmissions11 and JetJadeja",
    "events": {
      "CustomFeePercentUpdated(address,uint256)": {
        "params": {
          "newCustomFeePercent": "The new custom fee percentage for the Vault.",
          "vault": "The Vault that had its custom fee percentage set/updated."
        }
      },
      "CustomHarvestDelayUpdated(address,uint256)": {
        "params": {
          "newCustomHarvestDelay": "The new custom harvest delay for the Vault.",
          "vault": "The Vault that had its custom harvest delay set/updated."
        }
      },
      "CustomHarvestWindowUpdated(address,uint256)": {
        "params": {
          "newCustomHarvestWindow": "The new custom harvest window for the Vault.",
          "vault": "The Vault that had its custom harvest window set/updated."
        }
      },
      "CustomTargetFloatPercentUpdated(address,uint256)": {
        "params": {
          "newCustomTargetFloatPercent": "The new custom target float percentage for the Vault.",
          "vault": "The Vault that had its custom target float percentage set/updated."
        }
      },
      "DefaultFeePercentUpdated(uint256)": {
        "params": {
          "newDefaultFeePercent": "The new default fee percentage."
        }
      },
      "DefaultHarvestDelayUpdated(uint64)": {
        "params": {
          "newDefaultHarvestDelay": "The new default harvest delay."
        }
      },
      "DefaultHarvestWindowUpdated(uint128)": {
        "params": {
          "newDefaultHarvestWindow": "The new default harvest window."
        }
      },
      "DefaultTargetFloatPercentUpdated(uint256)": {
        "params": {
          "newDefaultTargetFloatPercent": "The new default target float percentage."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_authority": "The Authority of the module.",
          "_owner": "The owner of the module."
        }
      },
      "setDefaultFeePercent(uint256)": {
        "params": {
          "newDefaultFeePercent": "The new default fee percentage to set."
        }
      },
      "setDefaultHarvestDelay(uint64)": {
        "params": {
          "newDefaultHarvestDelay": "The new default harvest delay to set."
        }
      },
      "setDefaultHarvestWindow(uint128)": {
        "params": {
          "newDefaultHarvestWindow": "The new default harvest window to set."
        }
      },
      "setDefaultTargetFloatPercent(uint256)": {
        "params": {
          "newDefaultTargetFloatPercent": "The new default target float percentage to set."
        }
      },
      "setVaultCustomFeePercent(address,uint256)": {
        "params": {
          "customFeePercent": "The new custom fee percentage to set.",
          "vault": "The Vault to set the custom fee percentage for."
        }
      },
      "setVaultCustomHarvestDelay(address,uint64)": {
        "params": {
          "customHarvestDelay": "The new custom harvest delay to set.",
          "vault": "The Vault to set the custom harvest delay for."
        }
      },
      "setVaultCustomHarvestWindow(address,uint128)": {
        "params": {
          "customHarvestWindow": "The new custom harvest window to set.",
          "vault": "The Vault to set the custom harvest window for."
        }
      },
      "setVaultCustomTargetFloatPercent(address,uint256)": {
        "params": {
          "customTargetFloatPercent": "The new custom target float percentage to set.",
          "vault": "The Vault to set the custom target float percentage for."
        }
      },
      "syncFeePercent(address)": {
        "params": {
          "vault": "The Vault to sync the fee percentage for."
        }
      },
      "syncHarvestDelay(address)": {
        "params": {
          "vault": "The Vault to sync the harvest delay for."
        }
      },
      "syncHarvestWindow(address)": {
        "params": {
          "vault": "The Vault to sync the harvest window for."
        }
      },
      "syncTargetFloatPercent(address)": {
        "params": {
          "vault": "The Vault to sync the target float percentage for."
        }
      }
    },
    "stateVariables": {
      "getVaultCustomFeePercent": {
        "details": "Will be 0 if there is no custom fee percentage for the Vault."
      },
      "getVaultCustomHarvestDelay": {
        "details": "Will be 0 if there is no custom harvest delay for the Vault."
      },
      "getVaultCustomHarvestWindow": {
        "details": "Will be 0 if there is no custom harvest window for the Vault."
      },
      "getVaultCustomTargetFloatPercent": {
        "details": "Will be 0 if there is no custom target float percentage for the Vault."
      }
    },
    "title": "Rari Vault Configuration Module",
    "version": 1
  },
  "userdoc": {
    "events": {
      "CustomFeePercentUpdated(address,uint256)": {
        "notice": "Emitted when a Vault has its custom fee percentage set/updated."
      },
      "CustomHarvestDelayUpdated(address,uint256)": {
        "notice": "Emitted when a Vault has its custom harvest delay set/updated."
      },
      "CustomHarvestWindowUpdated(address,uint256)": {
        "notice": "Emitted when a Vault has its custom harvest window set/updated."
      },
      "CustomTargetFloatPercentUpdated(address,uint256)": {
        "notice": "Emitted when a Vault has its custom target float percentage set/updated."
      },
      "DefaultFeePercentUpdated(uint256)": {
        "notice": "Emitted when the default fee percentage is updated."
      },
      "DefaultHarvestDelayUpdated(uint64)": {
        "notice": "Emitted when the default harvest delay is updated."
      },
      "DefaultHarvestWindowUpdated(uint128)": {
        "notice": "Emitted when the default harvest window is updated."
      },
      "DefaultTargetFloatPercentUpdated(uint256)": {
        "notice": "Emitted when the default target float percentage is updated."
      }
    },
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Creates a Vault configuration module."
      },
      "defaultFeePercent()": {
        "notice": "The default fee percentage for Vaults."
      },
      "defaultHarvestDelay()": {
        "notice": "The default harvest delay for Vaults."
      },
      "defaultHarvestWindow()": {
        "notice": "The default harvest window for Vaults."
      },
      "defaultTargetFloatPercent()": {
        "notice": "The default target float percentage for Vaults."
      },
      "getVaultCustomFeePercent(address)": {
        "notice": "Maps Vaults to their custom fee percentage."
      },
      "getVaultCustomHarvestDelay(address)": {
        "notice": "Maps Vaults to their custom harvest delay."
      },
      "getVaultCustomHarvestWindow(address)": {
        "notice": "Maps Vaults to their custom harvest window."
      },
      "getVaultCustomTargetFloatPercent(address)": {
        "notice": "Maps Vaults to their custom target float percentage."
      },
      "setDefaultFeePercent(uint256)": {
        "notice": "Sets the default fee percentage for Vaults."
      },
      "setDefaultHarvestDelay(uint64)": {
        "notice": "Sets the default harvest delay for Vaults."
      },
      "setDefaultHarvestWindow(uint128)": {
        "notice": "Sets the default harvest window for Vaults."
      },
      "setDefaultTargetFloatPercent(uint256)": {
        "notice": "Sets the default target float percentage for Vaults."
      },
      "setVaultCustomFeePercent(address,uint256)": {
        "notice": "Sets the custom fee percentage for the Vault."
      },
      "setVaultCustomHarvestDelay(address,uint64)": {
        "notice": "Sets the custom harvest delay for the Vault."
      },
      "setVaultCustomHarvestWindow(address,uint128)": {
        "notice": "Sets the custom harvest window for the Vault."
      },
      "setVaultCustomTargetFloatPercent(address,uint256)": {
        "notice": "Sets the custom target float percentage for the Vault."
      },
      "syncFeePercent(address)": {
        "notice": "Syncs a Vault's fee percentage with either the Vault's custom fee percentage or the default fee percentage if a custom percentage is not set."
      },
      "syncHarvestDelay(address)": {
        "notice": "Syncs a Vault's harvest delay with either the Vault's custom harvest delay or the default harvest delay if a custom delay is not set."
      },
      "syncHarvestWindow(address)": {
        "notice": "Syncs a Vault's harvest window with either the Vault's custom harvest window or the default harvest window if a custom window is not set."
      },
      "syncTargetFloatPercent(address)": {
        "notice": "Syncs a Vault's target float percentage with either the Vault's custom target float percentage or the default target float percentage if a custom percentage is not set."
      }
    },
    "notice": "Module for configuring Vault parameters.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 9760,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 9763,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "authority",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(Authority)9748"
      },
      {
        "astId": 18304,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "defaultFeePercent",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 18307,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "defaultHarvestDelay",
        "offset": 0,
        "slot": "3",
        "type": "t_uint64"
      },
      {
        "astId": 18310,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "defaultHarvestWindow",
        "offset": 8,
        "slot": "3",
        "type": "t_uint128"
      },
      {
        "astId": 18313,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "defaultTargetFloatPercent",
        "offset": 0,
        "slot": "4",
        "type": "t_uint256"
      },
      {
        "astId": 18419,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "getVaultCustomFeePercent",
        "offset": 0,
        "slot": "5",
        "type": "t_mapping(t_contract(Vault)17624,t_uint256)"
      },
      {
        "astId": 18425,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "getVaultCustomHarvestDelay",
        "offset": 0,
        "slot": "6",
        "type": "t_mapping(t_contract(Vault)17624,t_uint64)"
      },
      {
        "astId": 18431,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "getVaultCustomHarvestWindow",
        "offset": 0,
        "slot": "7",
        "type": "t_mapping(t_contract(Vault)17624,t_uint128)"
      },
      {
        "astId": 18437,
        "contract": "src/vault/modules/VaultConfigurationModule.sol:VaultConfigurationModule",
        "label": "getVaultCustomTargetFloatPercent",
        "offset": 0,
        "slot": "8",
        "type": "t_mapping(t_contract(Vault)17624,t_uint256)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_contract(Authority)9748": {
        "encoding": "inplace",
        "label": "contract Authority",
        "numberOfBytes": "20"
      },
      "t_contract(Vault)17624": {
        "encoding": "inplace",
        "label": "contract Vault",
        "numberOfBytes": "20"
      },
      "t_mapping(t_contract(Vault)17624,t_uint128)": {
        "encoding": "mapping",
        "key": "t_contract(Vault)17624",
        "label": "mapping(contract Vault => uint128)",
        "numberOfBytes": "32",
        "value": "t_uint128"
      },
      "t_mapping(t_contract(Vault)17624,t_uint256)": {
        "encoding": "mapping",
        "key": "t_contract(Vault)17624",
        "label": "mapping(contract Vault => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_contract(Vault)17624,t_uint64)": {
        "encoding": "mapping",
        "key": "t_contract(Vault)17624",
        "label": "mapping(contract Vault => uint64)",
        "numberOfBytes": "32",
        "value": "t_uint64"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}
